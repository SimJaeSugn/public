# 1단계 연습문제 해답: @Transactional 기본 개념과 생명주기

## 문제 1: 기본 개념 이해 (10점)

### 문제
다음 중 @Transactional 어노테이션에 대한 설명으로 **틀린** 것은?

1. AOP를 통해 자동으로 트랜잭션을 관리한다
2. 클래스 레벨과 메서드 레벤 모두 적용 가능하다
3. private 메서드에도 트랜잭션이 적용된다
4. 메서드 레벤 설정이 클래스 레벤 설정보다 우선한다

### 답안
```
답: 3번

설명:
- @Transactional은 AOP를 통해 동작하므로 public 메서드에만 적용됩니다.
- private 메서드는 프록시를 통해 호출되지 않기 때문에 트랜잭션이 적용되지 않습니다.
- 클래스 레벤과 메서드 레벤 모두 적용 가능하며, 메서드 레벤 설정이 우선합니다.
```

---

## 문제 2: 트랜잭션 속성 (15점)

### 문제
다음 코드에서 `@Transactional` 어노테이션의 속성들을 설명하고, 각각의 역할을 작성하세요.

```java
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    readOnly = false,
    rollbackFor = {SQLException.class, DataAccessException.class}
)
public void complexBusinessMethod() {
    // 비즈니스 로직
}
```

### 답안
```
1. propagation: Propagation.REQUIRED
   역할: 기존 트랜잭션이 있으면 참여하고, 없으면 새로운 트랜잭션을 생성합니다.

2. isolation: Isolation.READ_COMMITTED
   역할: 커밋된 데이터만 읽을 수 있도록 하여 Dirty Read를 방지합니다.

3. timeout: 30
   역할: 트랜잭션 타임아웃을 30초로 설정하여 장시간 실행을 방지합니다.

4. readOnly: false
   역할: 읽기 전용이 아니므로 데이터 수정이 가능합니다.

5. rollbackFor: {SQLException.class, DataAccessException.class}
   역할: 지정된 예외 발생 시 트랜잭션을 롤백합니다.
```

---

## 문제 3: 트랜잭션 생명주기 (20점)

### 문제
다음 코드가 실행될 때 트랜잭션의 생명주기를 단계별로 설명하세요.

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        log.info("1. 메서드 시작");
        
        User savedUser = userRepository.save(user);
        log.info("2. 사용자 저장 완료: {}", savedUser.getId());
        
        if (savedUser.getEmail().contains("test")) {
            throw new RuntimeException("테스트 이메일은 허용되지 않습니다");
        }
        
        log.info("3. 메서드 정상 종료");
        return savedUser;
    }
}
```

### 답안
```
트랜잭션 생명주기:

1단계 (트랜잭션 시작):
- AOP 인터셉터가 메서드 호출을 가로챔
- 새로운 트랜잭션을 시작하고 Connection을 획득
- connection.setAutoCommit(false)로 자동 커밋 비활성화
- 트랜잭션 동기화 설정

2단계 (비즈니스 로직 실행):
- 실제 createUser 메서드 실행
- "1. 메서드 시작" 로그 출력
- userRepository.save() 실행 (같은 트랜잭션에 참여)
- "2. 사용자 저장 완료" 로그 출력
- 이메일 검증에서 RuntimeException 발생

3단계 (트랜잭션 종료):
- RuntimeException이 언체크 예외이므로 자동으로 롤백 처리
- connection.rollback() 실행
- 데이터베이스 변경사항이 모두 취소됨

4단계 (리소스 정리):
- 트랜잭션 동기화 정리
- Connection 반환
- 예외를 상위로 전파
```

---

## 문제 4: 예외 처리와 롤백 (15점)

### 문제
다음 코드에서 예외가 발생했을 때 트랜잭션이 어떻게 처리되는지 설명하세요.

```java
@Service
@Transactional
public class OrderService {
    
    public void processOrder(Order order) {
        try {
            // 주문 처리 로직
            validateOrder(order);
            saveOrder(order);
            processPayment(order);
            
        } catch (ValidationException e) {
            log.error("주문 검증 실패", e);
            // 예외를 다시 던지지 않음
        } catch (PaymentException e) {
            log.error("결제 처리 실패", e);
            throw e; // 예외를 다시 던짐
        }
    }
}
```

### 답안
```
ValidationException 발생 시:
- 트랜잭션이 커밋됩니다.
- 예외를 잡아서 처리하고 다시 던지지 않았기 때문에 정상 종료로 간주됩니다.

PaymentException 발생 시:
- 트랜잭션이 롤백됩니다.
- 예외를 다시 던졌기 때문에 트랜잭션이 실패로 간주됩니다.

이유:
- @Transactional은 기본적으로 언체크 예외(RuntimeException) 발생 시에만 롤백합니다.
- 예외를 잡아서 처리하면 트랜잭션은 성공으로 간주되어 커밋됩니다.
- 예외를 다시 던지면 트랜잭션이 실패로 간주되어 롤백됩니다.
```

---

## 문제 5: 트랜잭션 동기화 (20점)

### 문제
다음 코드에서 `TransactionSynchronization`을 사용하여 커밋 후에만 이메일을 발송하도록 수정하세요.

### 답안
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public User createUser(User user) {
        // 트랜잭션 동기화 등록
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    // 커밋 후에만 이메일 발송
                    emailService.sendWelcomeEmail(user.getEmail());
                }
                
                @Override
                public void afterRollback() {
                    // 롤백 시 로깅
                    log.warn("User creation rolled back, email not sent: {}", user.getEmail());
                }
            }
        );
        
        // 사용자 저장
        User savedUser = userRepository.save(user);
        
        return savedUser;
    }
}
```

**설명:**
- `TransactionSynchronizationManager.registerSynchronization()`을 사용하여 동기화 콜백을 등록합니다.
- `afterCommit()` 메서드에서 커밋 후에만 이메일을 발송합니다.
- `afterRollback()` 메서드에서 롤백 시 로깅을 추가했습니다.
- 이렇게 하면 트랜잭션이 성공적으로 커밋된 후에만 이메일이 발송됩니다.

---

## 문제 6: 실제 구현 (20점)

### 문제
다음 요구사항에 따라 `AccountService`를 구현하세요.

### 답안
```java
@Service
@Transactional(
    rollbackFor = {InsufficientFundsException.class, RuntimeException.class}
)
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 1. 출금 계좌 조회
        Account fromAccount = accountRepository.findById(fromAccountId)
            .orElseThrow(() -> new IllegalArgumentException("출금 계좌를 찾을 수 없습니다: " + fromAccountId));
        
        // 2. 입금 계좌 조회
        Account toAccount = accountRepository.findById(toAccountId)
            .orElseThrow(() -> new IllegalArgumentException("입금 계좌를 찾을 수 없습니다: " + toAccountId));
        
        // 3. 잔액 확인
        if (fromAccount.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException("잔액이 부족합니다. 현재 잔액: " + fromAccount.getBalance());
        }
        
        // 4. 출금 처리
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        accountRepository.save(fromAccount);
        
        // 5. 입금 처리
        toAccount.setBalance(toAccount.getBalance().add(amount));
        accountRepository.save(toAccount);
        
        // 6. 이체 성공 로그
        log.info("계좌 이체 성공: {} -> {}, 금액: {}", 
                fromAccount.getAccountNumber(), 
                toAccount.getAccountNumber(), 
                amount);
    }
}
```

**구현 설명:**
1. **트랜잭션 설정**: `@Transactional`에 `rollbackFor` 속성을 추가하여 지정된 예외 발생 시 롤백되도록 설정
2. **계좌 조회**: 출금 계좌와 입금 계좌를 조회하고 존재하지 않으면 예외 발생
3. **잔액 확인**: 출금 계좌의 잔액이 이체 금액보다 적으면 `InsufficientFundsException` 발생
4. **출금 처리**: 출금 계좌에서 금액을 차감하고 저장
5. **입금 처리**: 입금 계좌에 금액을 추가하고 저장
6. **로깅**: 이체 성공 시 로그 기록

**트랜잭션 동작:**
- 모든 작업이 성공하면 자동으로 커밋
- 예외 발생 시 자동으로 롤백하여 데이터 일관성 보장
- `InsufficientFundsException`이나 `RuntimeException` 발생 시 롤백

---

## 추가 학습 포인트

### 1. 트랜잭션 경계 이해
- `@Transactional` 메서드의 시작과 끝이 트랜잭션 경계
- 메서드 내부에서 예외가 발생하면 롤백, 정상 종료하면 커밋

### 2. 예외 처리 전략
- 체크 예외: 기본적으로 롤백되지 않음, `rollbackFor`로 설정 필요
- 언체크 예외: 기본적으로 롤백됨, `noRollbackFor`로 롤백 방지 가능

### 3. 트랜잭션 동기화 활용
- `TransactionSynchronization`을 사용하여 트랜잭션 생명주기에 따른 작업 수행
- 커밋 후에만 실행되어야 하는 작업에 유용

### 4. 실무 적용 시 주의사항
- 트랜잭션 범위를 최소화하여 성능 최적화
- 적절한 예외 처리로 롤백 조건 명확히 설정
- 로깅을 통한 트랜잭션 동작 모니터링
