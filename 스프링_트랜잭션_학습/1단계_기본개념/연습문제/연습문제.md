# 1단계 연습문제: @Transactional 기본 개념과 생명주기

## 문제 1: 기본 개념 이해 (10점)

### 문제
다음 중 @Transactional 어노테이션에 대한 설명으로 **틀린** 것은?

1. AOP를 통해 자동으로 트랜잭션을 관리한다
2. 클래스 레벨과 메서드 레벤 모두 적용 가능하다
3. private 메서드에도 트랜잭션이 적용된다
4. 메서드 레벨 설정이 클래스 레벨 설정보다 우선한다

### 답안 작성
```
답: 
```

---

## 문제 2: 트랜잭션 속성 (15점)

### 문제
다음 코드에서 `@Transactional` 어노테이션의 속성들을 설명하고, 각각의 역할을 작성하세요.

```java
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    readOnly = false,
    rollbackFor = {SQLException.class, DataAccessException.class}
)
public void complexBusinessMethod() {
    // 비즈니스 로직
}
```

### 답안 작성
```
1. propagation: 
   역할: 

2. isolation: 
   역할: 

3. timeout: 
   역할: 

4. readOnly: 
   역할: 

5. rollbackFor: 
   역할: 
```

---

## 문제 3: 트랜잭션 생명주기 (20점)

### 문제
다음 코드가 실행될 때 트랜잭션의 생명주기를 단계별로 설명하세요.

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        log.info("1. 메서드 시작");
        
        User savedUser = userRepository.save(user);
        log.info("2. 사용자 저장 완료: {}", savedUser.getId());
        
        if (savedUser.getEmail().contains("test")) {
            throw new RuntimeException("테스트 이메일은 허용되지 않습니다");
        }
        
        log.info("3. 메서드 정상 종료");
        return savedUser;
    }
}
```

### 답안 작성
```
트랜잭션 생명주기:

1단계 (트랜잭션 시작):
- 

2단계 (비즈니스 로직 실행):
- 

3단계 (트랜잭션 종료):
- 

4단계 (리소스 정리):
- 
```

---

## 문제 4: 예외 처리와 롤백 (15점)

### 문제
다음 코드에서 예외가 발생했을 때 트랜잭션이 어떻게 처리되는지 설명하세요.

```java
@Service
@Transactional
public class OrderService {
    
    public void processOrder(Order order) {
        try {
            // 주문 처리 로직
            validateOrder(order);
            saveOrder(order);
            processPayment(order);
            
        } catch (ValidationException e) {
            log.error("주문 검증 실패", e);
            // 예외를 다시 던지지 않음
        } catch (PaymentException e) {
            log.error("결제 처리 실패", e);
            throw e; // 예외를 다시 던짐
        }
    }
}
```

### 답안 작성
```
ValidationException 발생 시:
- 

PaymentException 발생 시:
- 

이유:
```

---

## 문제 5: 트랜잭션 동기화 (20점)

### 문제
다음 코드에서 `TransactionSynchronization`을 사용하여 커밋 후에만 이메일을 발송하도록 수정하세요.

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public User createUser(User user) {
        // 사용자 저장
        User savedUser = userRepository.save(user);
        
        // 이메일 발송 (트랜잭션과 관계없이 즉시 실행됨)
        emailService.sendWelcomeEmail(user.getEmail());
        
        return savedUser;
    }
}
```

### 답안 작성
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public User createUser(User user) {
        // 트랜잭션 동기화 등록
        // TODO: TransactionSynchronization을 사용하여 커밋 후에만 이메일 발송하도록 수정
        
        // 사용자 저장
        User savedUser = userRepository.save(user);
        
        return savedUser;
    }
}
```

---

## 문제 6: 실제 구현 (20점)

### 문제
다음 요구사항에 따라 `AccountService`를 구현하세요.

**요구사항:**
1. 계좌 이체 기능 구현
2. 출금 계좌 잔액 부족 시 예외 발생
3. 이체 실패 시 롤백 처리
4. 이체 성공 시 로그 기록
5. 적절한 트랜잭션 설정

**제공된 인터페이스:**
```java
public interface AccountRepository {
    Optional<Account> findById(Long id);
    Account save(Account account);
}

public class Account {
    private Long id;
    private String accountNumber;
    private BigDecimal balance;
    // getter, setter 생략
}

public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}
```

### 답안 작성
```java
@Service
@Transactional
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // TODO: 계좌 이체 로직 구현
        
    }
}
```

---

## 채점 기준

- **문제 1**: 10점 (정답 1개)
- **문제 2**: 15점 (각 속성당 3점)
- **문제 3**: 20점 (각 단계당 5점)
- **문제 4**: 15점 (각 예외 처리당 7.5점)
- **문제 5**: 20점 (TransactionSynchronization 구현)
- **문제 6**: 20점 (완전한 구현)

**총점: 100점**

## 평가 기준

- **90점 이상**: 우수 - 다음 단계 학습 가능
- **80-89점**: 양호 - 일부 복습 후 다음 단계 진행
- **70-79점**: 보통 - 추가 학습 필요
- **70점 미만**: 미흡 - 1단계 재학습 필요
