# 트랜잭션 생명주기와 동작 과정

## 1. 트랜잭션 생명주기 개요

### 생명주기 단계
1. **트랜잭션 시작** (BEGIN)
2. **비즈니스 로직 실행** (EXECUTE)
3. **트랜잭션 종료** (COMMIT/ROLLBACK)
4. **리소스 정리** (CLEANUP)

## 2. 상세한 트랜잭션 동작 과정

### 2.1 트랜잭션 시작 단계

#### AOP 인터셉터 동작
```java
// TransactionInterceptor.invoke()
public Object invoke(MethodInvocation invocation) throws Throwable {
    // 1. 트랜잭션 정의 생성
    TransactionDefinition definition = getTransactionDefinition(invocation);
    
    // 2. 트랜잭션 상태 확인
    TransactionStatus status = transactionManager.getTransaction(definition);
    
    // 3. 트랜잭션 동기화 설정
    if (status.isNewTransaction()) {
        bindResource();
    }
    
    // 4. 실제 메서드 호출
    try {
        return invocation.proceed();
    } catch (Exception e) {
        // 예외 처리
        handleException(status, e);
        throw e;
    } finally {
        // 리소스 정리
        cleanup(status);
    }
}
```

#### 트랜잭션 매니저의 동작
```java
// DataSourceTransactionManager.getTransaction()
public TransactionStatus getTransaction(TransactionDefinition definition) {
    // 1. 기존 트랜잭션 확인
    Object transaction = doGetTransaction();
    
    if (isExistingTransaction(transaction)) {
        // 기존 트랜잭션에 참여
        return handleExistingTransaction(definition, transaction);
    } else {
        // 새로운 트랜잭션 시작
        return startNewTransaction(definition, transaction);
    }
}

private TransactionStatus startNewTransaction(TransactionDefinition definition, Object transaction) {
    // 1. 데이터베이스 연결 획득
    Connection connection = getConnection();
    
    // 2. 자동 커밋 비활성화
    connection.setAutoCommit(false);
    
    // 3. 트랜잭션 상태 객체 생성
    return new DefaultTransactionStatus(transaction, true, true, false, true, null);
}
```

### 2.2 비즈니스 로직 실행 단계

#### 메서드 실행 과정
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        // 1. 트랜잭션 컨텍스트에서 실행
        // 2. 모든 데이터베이스 작업이 같은 트랜잭션에 참여
        User savedUser = userRepository.save(user);
        
        // 3. 추가 작업들도 같은 트랜잭션에 포함
        updateUserStatistics(savedUser);
        sendWelcomeEmail(savedUser);
        
        return savedUser;
    }
    
    private void updateUserStatistics(User user) {
        // 같은 트랜잭션에 참여
        statisticsRepository.incrementUserCount();
    }
    
    private void sendWelcomeEmail(User user) {
        // 같은 트랜잭션에 참여
        emailService.sendWelcomeEmail(user.getEmail());
    }
}
```

#### 트랜잭션 동기화 관리
```java
// TransactionSynchronizationManager
public class TransactionSynchronizationManager {
    
    // 현재 스레드의 트랜잭션 상태 관리
    private static final ThreadLocal<Map<Object, Object>> resources = new ThreadLocal<>();
    private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations = new ThreadLocal<>();
    
    // 리소스 바인딩
    public static void bindResource(Object key, Object value) {
        Map<Object, Object> map = resources.get();
        if (map == null) {
            map = new HashMap<>();
            resources.set(map);
        }
        map.put(key, value);
    }
    
    // 리소스 언바인딩
    public static Object unbindResource(Object key) {
        Map<Object, Object> map = resources.get();
        if (map == null) {
            return null;
        }
        Object value = map.remove(key);
        if (map.isEmpty()) {
            resources.remove();
        }
        return value;
    }
}
```

### 2.3 트랜잭션 종료 단계

#### 커밋 과정
```java
// DataSourceTransactionManager.commit()
public void commit(TransactionStatus status) {
    if (status.isRollbackOnly()) {
        // 롤백만 가능한 상태
        rollback(status);
        return;
    }
    
    if (status.isNewTransaction()) {
        // 새로운 트랜잭션인 경우
        doCommit(status);
    } else {
        // 기존 트랜잭션에 참여한 경우
        // 실제 커밋은 최상위 트랜잭션에서 처리
        prepareForCommit(status);
    }
}

private void doCommit(TransactionStatus status) {
    try {
        // 1. 커밋 전 콜백 실행
        triggerBeforeCommit(status);
        
        // 2. 데이터베이스 커밋
        connection.commit();
        
        // 3. 커밋 후 콜백 실행
        triggerAfterCommit(status);
        
    } catch (Exception e) {
        // 커밋 실패 시 롤백
        doRollback(status);
        throw e;
    }
}
```

#### 롤백 과정
```java
// DataSourceTransactionManager.rollback()
public void rollback(TransactionStatus status) {
    if (status.isNewTransaction()) {
        // 새로운 트랜잭션인 경우
        doRollback(status);
    } else {
        // 기존 트랜잭션에 참여한 경우
        // 최상위 트랜잭션에 롤백 마킹
        status.setRollbackOnly();
    }
}

private void doRollback(TransactionStatus status) {
    try {
        // 1. 롤백 전 콜백 실행
        triggerBeforeRollback(status);
        
        // 2. 데이터베이스 롤백
        connection.rollback();
        
        // 3. 롤백 후 콜백 실행
        triggerAfterRollback(status);
        
    } catch (Exception e) {
        // 롤백 실패 로깅
        log.error("Rollback failed", e);
        throw e;
    }
}
```

### 2.4 리소스 정리 단계

#### 정리 과정
```java
// TransactionInterceptor.cleanup()
private void cleanup(TransactionStatus status) {
    // 1. 트랜잭션 동기화 정리
    TransactionSynchronizationManager.clear();
    
    // 2. 리소스 정리
    if (status.isNewTransaction()) {
        // 새로운 트랜잭션인 경우
        transactionManager.cleanupAfterCompletion(status);
    }
    
    // 3. 연결 반환
    if (status.isNewTransaction()) {
        DataSourceUtils.releaseConnection(connection, dataSource);
    }
}
```

## 3. 트랜잭션 상태 관리

### 3.1 TransactionStatus 인터페이스
```java
public interface TransactionStatus {
    // 트랜잭션 활성화 여부
    boolean isNewTransaction();
    
    // 롤백만 가능한 상태인지
    boolean isRollbackOnly();
    
    // 롤백 마킹
    void setRollbackOnly();
    
    // 트랜잭션 완료 여부
    boolean isCompleted();
    
    // 저장점 지원 여부
    boolean hasSavepoint();
    
    // 저장점 생성
    Object createSavepoint();
    
    // 저장점 롤백
    void rollbackToSavepoint(Object savepoint);
    
    // 저장점 해제
    void releaseSavepoint(Object savepoint);
}
```

### 3.2 DefaultTransactionStatus 구현
```java
public class DefaultTransactionStatus implements TransactionStatus {
    
    private final Object transaction;
    private final boolean newTransaction;
    private final boolean newSynchronization;
    private final boolean readOnly;
    private final boolean debug;
    private final Object suspendedResources;
    
    private boolean rollbackOnly = false;
    private boolean completed = false;
    private Object savepoint;
    
    // 생성자
    public DefaultTransactionStatus(Object transaction, boolean newTransaction, 
                                  boolean newSynchronization, boolean readOnly, 
                                  boolean debug, Object suspendedResources) {
        this.transaction = transaction;
        this.newTransaction = newTransaction;
        this.newSynchronization = newSynchronization;
        this.readOnly = readOnly;
        this.debug = debug;
        this.suspendedResources = suspendedResources;
    }
    
    // 상태 확인 메서드들
    @Override
    public boolean isNewTransaction() {
        return this.newTransaction;
    }
    
    @Override
    public boolean isRollbackOnly() {
        return this.rollbackOnly;
    }
    
    @Override
    public void setRollbackOnly() {
        this.rollbackOnly = true;
    }
    
    @Override
    public boolean isCompleted() {
        return this.completed;
    }
    
    public void setCompleted() {
        this.completed = true;
    }
}
```

## 4. 트랜잭션 동기화 콜백

### 4.1 TransactionSynchronization 인터페이스
```java
public interface TransactionSynchronization {
    
    // 트랜잭션 상태 상수
    int STATUS_COMMITTED = 0;
    int STATUS_ROLLED_BACK = 1;
    int STATUS_UNKNOWN = 2;
    
    // 커밋 전 실행
    default void beforeCommit(boolean readOnly) {
    }
    
    // 커밋 후 실행
    default void afterCommit() {
    }
    
    // 롤백 후 실행
    default void afterRollback() {
    }
    
    // 트랜잭션 완료 후 실행
    default void afterCompletion(int status) {
    }
    
    // 트랜잭션 일시 중단 전 실행
    default void beforeCompletion() {
    }
}
```

### 4.2 동기화 콜백 사용 예제
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public User createUser(User user) {
        // 트랜잭션 동기화 등록
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    // 커밋 후에만 이메일 발송
                    emailService.sendWelcomeEmail(user.getEmail());
                }
                
                @Override
                public void afterRollback() {
                    // 롤백 시 로깅
                    log.warn("User creation rolled back for: {}", user.getEmail());
                }
            }
        );
        
        return userRepository.save(user);
    }
}
```

## 5. 실제 동작 과정 예제

### 5.1 간단한 트랜잭션 예제
```java
@Service
@Transactional
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 1. 트랜잭션 시작 (AOP에 의해 자동 처리)
        // TransactionStatus status = transactionManager.getTransaction(definition);
        
        try {
            // 2. 출금 계좌 조회 및 잔액 확인
            Account fromAccount = accountRepository.findById(fromAccountId)
                .orElseThrow(() -> new AccountNotFoundException("From account not found"));
            
            if (fromAccount.getBalance().compareTo(amount) < 0) {
                throw new InsufficientFundsException("Insufficient funds");
            }
            
            // 3. 출금 처리
            fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
            accountRepository.save(fromAccount);
            
            // 4. 입금 계좌 조회
            Account toAccount = accountRepository.findById(toAccountId)
                .orElseThrow(() -> new AccountNotFoundException("To account not found"));
            
            // 5. 입금 처리
            toAccount.setBalance(toAccount.getBalance().add(amount));
            accountRepository.save(toAccount);
            
            // 6. 트랜잭션 커밋 (AOP에 의해 자동 처리)
            // transactionManager.commit(status);
            
        } catch (Exception e) {
            // 7. 예외 발생 시 롤백 (AOP에 의해 자동 처리)
            // transactionManager.rollback(status);
            throw e;
        } finally {
            // 8. 리소스 정리 (AOP에 의해 자동 처리)
            // cleanup(status);
        }
    }
}
```

### 5.2 디버깅을 통한 동작 과정 확인
```java
@Service
@Transactional
public class DebugUserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        // 1. 현재 트랜잭션 상태 확인
        boolean isActive = TransactionSynchronizationManager.isActualTransactionActive();
        log.info("Transaction active: {}", isActive);
        
        // 2. 트랜잭션 동기화 등록
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void beforeCommit(boolean readOnly) {
                    log.info("Before commit - readOnly: {}", readOnly);
                }
                
                @Override
                public void afterCommit() {
                    log.info("After commit");
                }
                
                @Override
                public void afterRollback() {
                    log.info("After rollback");
                }
            }
        );
        
        // 3. 비즈니스 로직 실행
        User savedUser = userRepository.save(user);
        log.info("User saved: {}", savedUser.getId());
        
        return savedUser;
    }
}
```

## 6. 트랜잭션 생명주기 다이어그램

```
[메서드 호출] 
    ↓
[트랜잭션 시작]
    ↓
[비즈니스 로직 실행]
    ↓
[예외 발생?] → [예] → [롤백] → [리소스 정리] → [예외 전파]
    ↓ [아니오]
[커밋]
    ↓
[리소스 정리]
    ↓
[메서드 반환]
```

## 7. 주의사항

### 7.1 트랜잭션 경계
- `@Transactional` 메서드의 시작과 끝이 트랜잭션 경계
- 메서드 내부에서 다른 `@Transactional` 메서드 호출 시 전파 규칙 적용

### 7.2 예외 처리
- 체크 예외는 기본적으로 롤백되지 않음
- 언체크 예외는 기본적으로 롤백됨
- 예외를 잡아서 처리하면 롤백되지 않음

### 7.3 리소스 관리
- 트랜잭션 종료 시 자동으로 리소스 정리
- 수동으로 리소스를 관리할 필요 없음

이제 다음 학습 자료에서 트랜잭션 전파 메커니즘에 대해 알아보겠습니다.
