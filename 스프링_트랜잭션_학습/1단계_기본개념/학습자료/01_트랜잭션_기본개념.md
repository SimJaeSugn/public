# 트랜잭션의 기본 개념

## 1. 트랜잭션이란?

### 정의
트랜잭션(Transaction)은 데이터베이스에서 **하나의 논리적 작업 단위**를 구성하는 일련의 연산들을 의미합니다. 이 연산들은 모두 성공하거나 모두 실패해야 하는 원자성(Atomicity)을 가집니다.

### 특징
- **원자성(Atomicity)**: 트랜잭션의 모든 작업이 성공하거나 모두 실패
- **일관성(Consistency)**: 트랜잭션 실행 후에도 데이터베이스의 무결성 유지
- **격리성(Isolation)**: 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않음
- **지속성(Durability)**: 커밋된 트랜잭션의 결과는 영구적으로 보존

## 2. 트랜잭션이 필요한 이유

### 데이터 무결성 보장
```java
// 예시: 계좌 이체 작업
public void transferMoney(String fromAccount, String toAccount, int amount) {
    // 1. 출금 계좌에서 금액 차감
    withdraw(fromAccount, amount);
    
    // 2. 입금 계좌에 금액 추가
    deposit(toAccount, amount);
}
```

위 코드에서 1번은 성공하고 2번이 실패한다면, 출금만 되고 입금은 안 되는 문제가 발생합니다. 이를 방지하기 위해 트랜잭션을 사용합니다.

### 동시성 제어
여러 사용자가 동시에 같은 데이터를 수정할 때 발생할 수 있는 문제들을 방지합니다.

## 3. 스프링에서의 트랜잭션 관리

### 선언적 트랜잭션 관리
- `@Transactional` 어노테이션을 사용
- AOP를 통해 자동으로 트랜잭션 관리
- 코드와 트랜잭션 로직의 분리

### 프로그래밍적 트랜잭션 관리
- `TransactionTemplate` 사용
- 명시적으로 트랜잭션 제어
- 복잡한 트랜잭션 로직이 필요한 경우 사용

## 4. 트랜잭션의 생명주기

### 1단계: 트랜잭션 시작
```java
// 스프링이 자동으로 처리
Connection connection = dataSource.getConnection();
connection.setAutoCommit(false); // 자동 커밋 비활성화
```

### 2단계: 비즈니스 로직 실행
```java
// @Transactional이 적용된 메서드 실행
@Transactional
public void businessMethod() {
    // 데이터베이스 작업들...
}
```

### 3단계: 트랜잭션 종료
```java
// 성공 시
connection.commit();

// 실패 시
connection.rollback();
```

## 5. 트랜잭션 상태

### Active (활성)
- 트랜잭션이 실행 중인 상태
- SQL 문이 실행되고 있는 상태

### Committed (커밋됨)
- 트랜잭션이 성공적으로 완료된 상태
- 변경사항이 데이터베이스에 영구 저장

### Aborted (중단됨)
- 트랜잭션이 실패한 상태
- 변경사항이 롤백됨

### Partially Committed (부분 커밋)
- 마지막 SQL 문이 실행된 후 커밋 전 상태

## 6. 트랜잭션 경계

### 트랜잭션 시작점
- `@Transactional` 메서드 호출 시점
- 새로운 트랜잭션이 시작되거나 기존 트랜잭션에 참여

### 트랜잭션 종료점
- 메서드 정상 종료 시 (커밋)
- 예외 발생 시 (롤백)

## 7. 트랜잭션과 예외 처리

### 체크 예외 (Checked Exception)
- 기본적으로 롤백되지 않음
- `rollbackFor` 속성으로 롤백 설정 가능

### 언체크 예외 (Unchecked Exception)
- 기본적으로 롤백됨
- `noRollbackFor` 속성으로 롤백 방지 가능

```java
@Transactional(rollbackFor = Exception.class)
public void methodWithCheckedException() throws Exception {
    // 체크 예외도 롤백되도록 설정
}

@Transactional(noRollbackFor = RuntimeException.class)
public void methodWithUncheckedException() {
    // 런타임 예외도 롤백되지 않도록 설정
}
```

## 8. 트랜잭션 매니저

### PlatformTransactionManager
- 스프링의 트랜잭션 관리 추상화
- 다양한 트랜잭션 매니저 구현체 제공

### 주요 구현체
- `DataSourceTransactionManager`: JDBC 트랜잭션
- `JpaTransactionManager`: JPA 트랜잭션
- `JtaTransactionManager`: JTA 트랜잭션

## 9. 트랜잭션 동기화

### TransactionSynchronizationManager
- 현재 스레드의 트랜잭션 상태 관리
- 트랜잭션과 관련된 리소스 동기화

### 주요 메서드
```java
// 현재 트랜잭션 활성화 여부 확인
boolean isActualTransactionActive();

// 트랜잭션 동기화 등록
void registerSynchronization(TransactionSynchronization synchronization);

// 현재 트랜잭션 상태 조회
TransactionStatus getCurrentTransactionStatus();
```

## 10. 실제 사용 예제

### 기본 사용법
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional(readOnly = true)
    public User findById(Long id) {
        return userRepository.findById(id);
    }
    
    @Transactional
    public User save(User user) {
        return userRepository.save(user);
    }
    
    @Transactional
    public void deleteById(Long id) {
        userRepository.deleteById(id);
    }
}
```

### 트랜잭션 속성 설정
```java
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    readOnly = false,
    rollbackFor = Exception.class
)
public void complexBusinessMethod() {
    // 복잡한 비즈니스 로직
}
```

이제 다음 학습 자료에서 @Transactional 어노테이션의 상세한 사용법을 알아보겠습니다.
