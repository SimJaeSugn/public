# 3단계 연습문제: 트랜잭션 격리 수준(Isolation)과 동시성 제어

## 문제 1: 격리 수준 기본 이해 (15점)

### 문제
다음 중 트랜잭션 격리 수준에 대한 설명으로 **틀린** 것은?

1. READ_UNCOMMITTED는 가장 낮은 격리 수준으로 모든 동시성 문제가 발생할 수 있다
2. READ_COMMITTED는 커밋된 데이터만 읽을 수 있어 Dirty Read를 방지한다
3. REPEATABLE_READ는 반복 읽기 일관성을 보장하여 Phantom Read를 방지한다
4. SERIALIZABLE는 가장 높은 격리 수준으로 모든 동시성 문제를 방지한다

### 답안 작성
```
답: 

설명:
```

---

## 문제 2: 동시성 문제 분석 (20점)

### 문제
다음 코드에서 발생할 수 있는 동시성 문제를 분석하고, 적절한 격리 수준을 제안하세요.

```java
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 1. 출금 계좌 조회
        Account fromAccount = accountRepository.findById(fromAccountId);
        
        // 2. 잔액 확인
        if (fromAccount.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException("Insufficient funds");
        }
        
        // 3. 출금 처리
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        accountRepository.save(fromAccount);
        
        // 4. 입금 계좌 조회
        Account toAccount = accountRepository.findById(toAccountId);
        
        // 5. 입금 처리
        toAccount.setBalance(toAccount.getBalance().add(amount));
        accountRepository.save(toAccount);
    }
}
```

### 답안 작성
```
발생 가능한 동시성 문제:

1. 
   문제: 
   설명: 

2. 
   문제: 
   설명: 

3. 
   문제: 
   설명: 

제안하는 격리 수준: 
이유: 
```

---

## 문제 3: 격리 수준별 동작 분석 (25점)

### 문제
다음 시나리오에서 각 격리 수준의 동작을 분석하세요.

**시나리오:**
- 트랜잭션 1: 사용자 정보를 "John"에서 "Jane"으로 수정
- 트랜잭션 2: 같은 사용자 정보를 두 번 읽기

**코드:**
```java
// 트랜잭션 1
@Service
@Transactional(isolation = Isolation.???)
public class UserService {
    
    public void updateUser(Long userId, String newName) {
        User user = userRepository.findById(userId);
        user.setName(newName);
        userRepository.save(user);
        // 커밋
    }
}

// 트랜잭션 2
@Service
@Transactional(isolation = Isolation.???)
public class UserService {
    
    public void readUserTwice(Long userId) {
        User user1 = userRepository.findById(userId);
        System.out.println("First read: " + user1.getName());
        
        // 트랜잭션 1이 실행됨
        
        User user2 = userRepository.findById(userId);
        System.out.println("Second read: " + user2.getName());
    }
}
```

### 답안 작성
```
READ_UNCOMMITTED:
- 첫 번째 읽기: 
- 두 번째 읽기: 
- 발생하는 문제: 

READ_COMMITTED:
- 첫 번째 읽기: 
- 두 번째 읽기: 
- 발생하는 문제: 

REPEATABLE_READ:
- 첫 번째 읽기: 
- 두 번째 읽기: 
- 발생하는 문제: 

SERIALIZABLE:
- 첫 번째 읽기: 
- 두 번째 읽기: 
- 발생하는 문제: 
```

---

## 문제 4: 실제 코드 구현 (25점)

### 문제
다음 요구사항에 따라 적절한 격리 수준을 사용하여 코드를 구현하세요.

**요구사항:**
1. 사용자 등록 시 이메일 중복 확인 (읽기 일관성 중요)
2. 재고 관리 시 동시 업데이트 방지 (Lost Update 방지)
3. 통계 생성 시 성능 최적화 (정확한 수치 불필요)
4. 금융 거래 시 데이터 일관성 보장 (모든 동시성 문제 방지)

**제공된 인터페이스:**
```java
public interface UserRepository {
    User findByEmail(String email);
    User save(User user);
}

public interface ProductRepository {
    Product findById(Long id);
    Product save(Product product);
}

public interface StatisticsRepository {
    long countUsers();
    double getAverageAge();
}

public interface AccountRepository {
    Account findById(Long id);
    Account save(Account account);
}
```

### 답안 작성
```java
// 1. 사용자 등록 서비스
@Service
@Transactional(isolation = Isolation.???)
public class UserRegistrationService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User registerUser(User user) {
        // TODO: 이메일 중복 확인 및 사용자 등록
    }
}

// 2. 재고 관리 서비스
@Service
@Transactional(isolation = Isolation.???)
public class InventoryService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public void updateStock(Long productId, int quantity) {
        // TODO: 재고 업데이트 (Lost Update 방지)
    }
}

// 3. 통계 서비스
@Service
@Transactional(isolation = Isolation.???)
public class StatisticsService {
    
    @Autowired
    private StatisticsRepository statisticsRepository;
    
    public Statistics generateStatistics() {
        // TODO: 통계 생성 (성능 최적화)
    }
}

// 4. 금융 거래 서비스
@Service
@Transactional(isolation = Isolation.???)
public class FinancialTransactionService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void processTransaction(Transaction transaction) {
        // TODO: 금융 거래 처리 (데이터 일관성 보장)
    }
}
```

---

## 문제 5: 성능 최적화 (15점)

### 문제
다음 코드의 성능 문제를 분석하고 최적화 방안을 제시하세요.

```java
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    public void processOrder(Order order) {
        // 1. 사용자 검증
        User user = userRepository.findById(order.getUserId());
        if (user == null) {
            throw new UserNotFoundException("User not found");
        }
        
        // 2. 제품 검증
        Product product = productRepository.findById(order.getProductId());
        if (product == null) {
            throw new ProductNotFoundException("Product not found");
        }
        
        // 3. 재고 확인
        if (product.getStock() < order.getQuantity()) {
            throw new InsufficientStockException("Insufficient stock");
        }
        
        // 4. 외부 API 호출 (시간이 오래 걸림)
        callExternalAPI(order);
        
        // 5. 주문 저장
        orderRepository.save(order);
        
        // 6. 재고 차감
        product.setStock(product.getStock() - order.getQuantity());
        productRepository.save(product);
    }
    
    private void callExternalAPI(Order order) {
        // 외부 API 호출 로직
        // 시간이 오래 걸리는 작업
    }
}
```

### 답안 작성
```
성능 문제 분석:

1. 
   문제: 
   영향: 

2. 
   문제: 
   영향: 

3. 
   문제: 
   영향: 

최적화 방안:

1. 
   방법: 
   효과: 

2. 
   방법: 
   효과: 

3. 
   방법: 
   효과: 

최적화된 코드:
```

---

## 채점 기준

- **문제 1**: 15점 (정답 1개)
- **문제 2**: 20점 (각 문제당 6.7점)
- **문제 3**: 25점 (각 격리 수준당 6.25점)
- **문제 4**: 25점 (각 서비스당 6.25점)
- **문제 5**: 15점 (문제 분석 및 해결)

**총점: 100점**

## 평가 기준

- **90점 이상**: 우수 - 다음 단계 학습 가능
- **80-89점**: 양호 - 일부 복습 후 다음 단계 진행
- **70-79점**: 보통 - 추가 학습 필요
- **70점 미만**: 미흡 - 3단계 재학습 필요
