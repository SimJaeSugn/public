# 3단계 연습문제 해답: 트랜잭션 격리 수준(Isolation)과 동시성 제어

## 문제 1: 격리 수준 기본 이해 (15점)

### 문제
다음 중 트랜잭션 격리 수준에 대한 설명으로 **틀린** 것은?

### 답안
```
답: 3번

설명:
- REPEATABLE_READ는 반복 읽기 일관성을 보장하여 Non-Repeatable Read를 방지하지만, Phantom Read는 방지하지 못합니다.
- Phantom Read는 SERIALIZABLE 격리 수준에서만 방지됩니다.
- REPEATABLE_READ에서는 새로운 행이 나타나거나 사라지는 문제(Phantom Read)가 발생할 수 있습니다.
```

---

## 문제 2: 동시성 문제 분석 (20점)

### 문제
다음 코드에서 발생할 수 있는 동시성 문제를 분석하고, 적절한 격리 수준을 제안하세요.

### 답안
```
발생 가능한 동시성 문제:

1. Non-Repeatable Read
   문제: 같은 계좌 정보를 두 번 읽을 때 다른 결과가 나올 수 있음
   설명: 첫 번째 읽기와 두 번째 읽기 사이에 다른 트랜잭션이 계좌 정보를 수정할 수 있음

2. Lost Update
   문제: 동시에 같은 계좌를 업데이트할 때 업데이트가 손실될 수 있음
   설명: 두 트랜잭션이 동시에 계좌 잔액을 읽고 수정하면, 하나의 업데이트가 손실됨

3. Dirty Read
   문제: 커밋되지 않은 데이터를 읽을 수 있음
   설명: READ_COMMITTED에서는 방지되지만, 더 낮은 격리 수준에서는 발생 가능

제안하는 격리 수준: REPEATABLE_READ
이유: 
- Non-Repeatable Read를 방지하여 계좌 정보의 일관성 보장
- Lost Update를 방지하여 동시 업데이트 문제 해결
- 계좌 이체와 같은 중요한 금융 작업에 적합
- SERIALIZABLE보다 성능이 좋으면서도 충분한 일관성 보장
```

---

## 문제 3: 격리 수준별 동작 분석 (25점)

### 답안
```
READ_UNCOMMITTED:
- 첫 번째 읽기: "John" (커밋되지 않은 데이터도 읽을 수 있음)
- 두 번째 읽기: "Jane" (커밋되지 않은 데이터도 읽을 수 있음)
- 발생하는 문제: Dirty Read, Non-Repeatable Read

READ_COMMITTED:
- 첫 번째 읽기: "John" (커밋된 데이터만 읽음)
- 두 번째 읽기: "Jane" (트랜잭션 1이 커밋된 후 읽음)
- 발생하는 문제: Non-Repeatable Read

REPEATABLE_READ:
- 첫 번째 읽기: "John" (읽기 일관성 보장)
- 두 번째 읽기: "John" (같은 결과 보장)
- 발생하는 문제: 없음 (Non-Repeatable Read 방지)

SERIALIZABLE:
- 첫 번째 읽기: "John" (모든 동시성 문제 방지)
- 두 번째 읽기: "John" (같은 결과 보장)
- 발생하는 문제: 없음 (모든 동시성 문제 방지)
- 추가: 트랜잭션 1이 완료될 때까지 트랜잭션 2가 대기
```

---

## 문제 4: 실제 코드 구현 (25점)

### 답안
```java
// 1. 사용자 등록 서비스
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class UserRegistrationService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User registerUser(User user) {
        // 이메일 중복 확인 (읽기 일관성 중요)
        User existingUser = userRepository.findByEmail(user.getEmail());
        if (existingUser != null) {
            throw new DuplicateEmailException("Email already exists");
        }
        
        // 사용자 등록
        return userRepository.save(user);
    }
}

// 2. 재고 관리 서비스
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class InventoryService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public void updateStock(Long productId, int quantity) {
        // 재고 업데이트 (Lost Update 방지)
        Product product = productRepository.findById(productId);
        if (product.getStock() < quantity) {
            throw new InsufficientStockException("Insufficient stock");
        }
        
        product.setStock(product.getStock() - quantity);
        productRepository.save(product);
    }
}

// 3. 통계 서비스
@Service
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public class StatisticsService {
    
    @Autowired
    private StatisticsRepository statisticsRepository;
    
    public Statistics generateStatistics() {
        // 통계 생성 (성능 최적화)
        long userCount = statisticsRepository.countUsers();
        double averageAge = statisticsRepository.getAverageAge();
        
        return new Statistics(userCount, averageAge);
    }
}

// 4. 금융 거래 서비스
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class FinancialTransactionService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void processTransaction(Transaction transaction) {
        // 금융 거래 처리 (데이터 일관성 보장)
        Account account = accountRepository.findById(transaction.getAccountId());
        
        if (account.getBalance().compareTo(transaction.getAmount()) < 0) {
            throw new InsufficientFundsException("Insufficient funds");
        }
        
        account.setBalance(account.getBalance().subtract(transaction.getAmount()));
        accountRepository.save(account);
    }
}
```

**설명:**
1. **UserRegistrationService**: REPEATABLE_READ 사용 - 이메일 중복 확인 시 읽기 일관성 보장
2. **InventoryService**: REPEATABLE_READ 사용 - 재고 업데이트 시 Lost Update 방지
3. **StatisticsService**: READ_UNCOMMITTED 사용 - 성능 최적화, 정확한 수치 불필요
4. **FinancialTransactionService**: SERIALIZABLE 사용 - 금융 거래는 데이터 일관성이 매우 중요

---

## 문제 5: 성능 최적화 (15점)

### 답안
```
성능 문제 분석:

1. SERIALIZABLE 격리 수준 사용
   문제: 가장 높은 격리 수준으로 성능 저하
   영향: 동시성이 최소화되고 락 사용량이 최대

2. 긴 트랜잭션 범위
   문제: 외부 API 호출까지 트랜잭션 내에서 실행
   영향: 트랜잭션이 오래 유지되어 락 경합 증가

3. 불필요한 SERIALIZABLE 사용
   문제: 모든 작업에 SERIALIZABLE 적용
   영향: 성능 저하와 동시성 감소

최적화 방안:

1. 격리 수준 분리
   방법: 필요한 작업만 높은 격리 수준 사용
   효과: 성능 향상과 동시성 증가

2. 트랜잭션 범위 최소화
   방법: 외부 API 호출을 트랜잭션 외부로 분리
   효과: 락 유지 시간 단축

3. 적절한 격리 수준 선택
   방법: 작업 특성에 맞는 격리 수준 사용
   효과: 성능과 일관성의 균형

최적화된 코드:
```

```java
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    public void processOrder(Order order) {
        // 1. 사용자 검증 (트랜잭션 내)
        User user = userRepository.findById(order.getUserId());
        if (user == null) {
            throw new UserNotFoundException("User not found");
        }
        
        // 2. 제품 검증 (트랜잭션 내)
        Product product = productRepository.findById(order.getProductId());
        if (product == null) {
            throw new ProductNotFoundException("Product not found");
        }
        
        // 3. 재고 확인 (트랜잭션 내)
        if (product.getStock() < order.getQuantity()) {
            throw new InsufficientStockException("Insufficient stock");
        }
        
        // 4. 주문 저장 (트랜잭션 내)
        orderRepository.save(order);
        
        // 5. 재고 차감 (트랜잭션 내)
        product.setStock(product.getStock() - order.getQuantity());
        productRepository.save(product);
        
        // 6. 외부 API 호출 (트랜잭션 외부)
        callExternalAPIAsync(order);
    }
    
    @Async
    private void callExternalAPIAsync(Order order) {
        // 외부 API 호출 로직
        // 비동기로 실행하여 트랜잭션과 분리
    }
}

// 추가: 재고 관리 서비스 분리
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class InventoryService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public void updateStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId);
        if (product.getStock() < quantity) {
            throw new InsufficientStockException("Insufficient stock");
        }
        
        product.setStock(product.getStock() - quantity);
        productRepository.save(product);
    }
}
```

**최적화 포인트:**
1. **격리 수준 변경**: SERIALIZABLE → REPEATABLE_READ
2. **트랜잭션 범위 최소화**: 외부 API 호출을 비동기로 분리
3. **서비스 분리**: 재고 관리를 별도 서비스로 분리
4. **비동기 처리**: 외부 API 호출을 @Async로 비동기 처리

---

## 추가 학습 포인트

### 1. 격리 수준 선택 기준
- **READ_UNCOMMITTED**: 통계, 집계 작업
- **READ_COMMITTED**: 일반적인 CRUD 작업
- **REPEATABLE_READ**: 읽기 일관성이 중요한 작업
- **SERIALIZABLE**: 데이터 일관성이 매우 중요한 작업

### 2. 성능 최적화 전략
- 트랜잭션 범위 최소화
- 적절한 격리 수준 선택
- 비동기 처리 활용
- 서비스 분리를 통한 책임 분리

### 3. 실무 적용 시 주의사항
- 성능과 일관성의 균형점 찾기
- 데드락 방지 전략 수립
- 모니터링을 통한 성능 측정
- 단계적 최적화 접근
