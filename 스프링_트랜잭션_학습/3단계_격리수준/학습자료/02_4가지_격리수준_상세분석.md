# 4가지 트랜잭션 격리 수준 상세 분석

## 1. READ_UNCOMMITTED (읽기 미커밋)

### 1.1 기본 개념
- **가장 낮은 격리 수준**
- 커밋되지 않은 데이터도 읽을 수 있음
- 모든 동시성 문제 발생 가능
- 성능은 가장 높지만 데이터 일관성은 가장 낮음

### 1.2 동작 원리
```java
@Service
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void updateUser(Long userId, String newName) {
        User user = userRepository.findById(userId);
        user.setName(newName);
        userRepository.save(user);
        // 아직 커밋되지 않음
        // 다른 트랜잭션에서 이 데이터를 읽을 수 있음
    }
    
    public User findUser(Long userId) {
        // 커밋되지 않은 데이터도 읽을 수 있음
        return userRepository.findById(userId);
    }
}
```

### 1.3 락 사용량
```java
// READ_UNCOMMITTED에서는 락을 거의 사용하지 않음
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void readData(Long id) {
    // SELECT 시 락을 걸지 않음
    User user = userRepository.findById(id);
    // 다른 트랜잭션이 동시에 같은 데이터를 수정할 수 있음
}
```

### 1.4 발생 가능한 문제
```java
// Dirty Read 발생 예제
@Service
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public class DirtyReadExample {
    
    public void demonstrateDirtyRead() {
        // 트랜잭션 1: 사용자 정보 수정
        User user = userRepository.findById(1L);
        user.setName("Modified Name");
        userRepository.save(user);
        // 아직 커밋되지 않음
        
        // 트랜잭션 2: 사용자 정보 읽기
        User readUser = userRepository.findById(1L);
        System.out.println(readUser.getName()); // "Modified Name" 출력
        // 하지만 트랜잭션 1이 롤백되면 이 데이터는 잘못된 데이터
    }
}
```

### 1.5 사용 사례
```java
// 통계나 집계 작업에 사용
@Service
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public class StatisticsService {
    
    public long getTotalUserCount() {
        // 정확한 수치가 아니어도 되는 통계 작업
        return userRepository.count();
    }
    
    public double getAverageAge() {
        // 근사치로도 충분한 집계 작업
        return userRepository.getAverageAge();
    }
}
```

## 2. READ_COMMITTED (읽기 커밋)

### 2.1 기본 개념
- **가장 일반적으로 사용되는 격리 수준**
- 커밋된 데이터만 읽을 수 있음
- Dirty Read는 방지하지만 Non-Repeatable Read와 Phantom Read는 발생 가능
- 성능과 일관성의 균형점

### 2.2 동작 원리
```java
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void updateUser(Long userId, String newName) {
        User user = userRepository.findById(userId);
        user.setName(newName);
        userRepository.save(user);
        // 커밋되기 전까지는 다른 트랜잭션에서 읽을 수 없음
    }
    
    public User findUser(Long userId) {
        // 커밋된 데이터만 읽을 수 있음
        return userRepository.findById(userId);
    }
}
```

### 2.3 락 사용량
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readData(Long id) {
    // SELECT 시 공유 락 획득
    User user = userRepository.findById(id);
    // 읽기 완료 후 락 해제
    // 다른 트랜잭션이 수정할 수 있음
}

@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateData(Long id, String newName) {
    // UPDATE 시 배타 락 획득
    User user = userRepository.findById(id);
    user.setName(newName);
    userRepository.save(user);
    // 커밋까지 락 유지
}
```

### 2.4 발생 가능한 문제
```java
// Non-Repeatable Read 발생 예제
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class NonRepeatableReadExample {
    
    public void demonstrateNonRepeatableRead() {
        // 첫 번째 읽기
        User user1 = userRepository.findById(1L);
        System.out.println("First read: " + user1.getName());
        
        // 다른 트랜잭션이 사용자 정보를 수정하고 커밋
        
        // 두 번째 읽기
        User user2 = userRepository.findById(1L);
        System.out.println("Second read: " + user2.getName());
        // user1.getName() != user2.getName()
    }
}
```

### 2.5 사용 사례
```java
// 일반적인 CRUD 작업에 사용
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class UserService {
    
    public User findById(Long id) {
        // 커밋된 데이터만 읽음
        return userRepository.findById(id);
    }
    
    public User save(User user) {
        // 업데이트 시 배타 락으로 일관성 보장
        return userRepository.save(user);
    }
    
    public void deleteById(Long id) {
        // 삭제 시 배타 락으로 일관성 보장
        userRepository.deleteById(id);
    }
}
```

## 3. REPEATABLE_READ (반복 읽기)

### 3.1 기본 개념
- **반복 읽기 일관성 보장**
- Dirty Read와 Non-Repeatable Read 방지
- Phantom Read는 발생 가능
- 읽기 작업이 많은 애플리케이션에 적합

### 3.2 동작 원리
```java
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void readUserTwice(Long userId) {
        // 첫 번째 읽기
        User user1 = userRepository.findById(userId);
        System.out.println("First read: " + user1.getName());
        
        // 다른 트랜잭션이 같은 사용자를 수정해도
        // 두 번째 읽기에서는 같은 결과
        
        // 두 번째 읽기
        User user2 = userRepository.findById(userId);
        System.out.println("Second read: " + user2.getName());
        // user1.getName() == user2.getName()
    }
}
```

### 3.3 락 사용량
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void readData(Long id) {
    // SELECT 시 공유 락 획득
    User user = userRepository.findById(id);
    // 트랜잭션 종료까지 락 유지
    // 다른 트랜잭션이 수정할 수 없음
}

@Transactional(isolation = Isolation.REPEATABLE_READ)
public void updateData(Long id, String newName) {
    // UPDATE 시 배타 락 획득
    User user = userRepository.findById(id);
    user.setName(newName);
    userRepository.save(user);
    // 트랜잭션 종료까지 락 유지
}
```

### 3.4 발생 가능한 문제
```java
// Phantom Read 발생 예제
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class PhantomReadExample {
    
    public void demonstratePhantomRead() {
        // 첫 번째 읽기
        List<User> users1 = userRepository.findByAgeGreaterThan(25);
        System.out.println("First read count: " + users1.size());
        
        // 다른 트랜잭션이 새로운 사용자를 추가하고 커밋
        
        // 두 번째 읽기
        List<User> users2 = userRepository.findByAgeGreaterThan(25);
        System.out.println("Second read count: " + users2.size());
        // users1.size() != users2.size()
    }
}
```

### 3.5 사용 사례
```java
// 읽기 일관성이 중요한 작업에 사용
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class AccountService {
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 반복 읽기 일관성 보장
        Account fromAccount = accountRepository.findById(fromAccountId);
        Account toAccount = accountRepository.findById(toAccountId);
        
        // 같은 쿼리를 반복 실행해도 같은 결과
        if (fromAccount.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException("Insufficient funds");
        }
        
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        toAccount.setBalance(toAccount.getBalance().add(amount));
        
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
    }
}
```

## 4. SERIALIZABLE (직렬화)

### 4.1 기본 개념
- **가장 높은 격리 수준**
- 모든 동시성 문제 방지
- 성능은 가장 낮지만 데이터 일관성은 가장 높음
- 트랜잭션들이 순차적으로 실행되는 것처럼 동작

### 4.2 동작 원리
```java
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void criticalOperation(Long userId) {
        // 모든 동시성 문제가 방지됨
        User user = userRepository.findById(userId);
        user.setName("Critical Update");
        userRepository.save(user);
        // 다른 트랜잭션은 이 작업이 완료될 때까지 대기
    }
}
```

### 4.3 락 사용량
```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void readData(Long id) {
    // SELECT 시 공유 락 획득
    User user = userRepository.findById(id);
    // 트랜잭션 종료까지 락 유지
    // 다른 트랜잭션은 읽기/쓰기 모두 불가능
}

@Transactional(isolation = Isolation.SERIALIZABLE)
public void updateData(Long id, String newName) {
    // UPDATE 시 배타 락 획득
    User user = userRepository.findById(id);
    user.setName(newName);
    userRepository.save(user);
    // 트랜잭션 종료까지 락 유지
    // 다른 트랜잭션은 읽기/쓰기 모두 불가능
}
```

### 4.4 발생 가능한 문제
```java
// 데드락 발생 가능성
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class DeadlockExample {
    
    public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
        // 데드락 발생 가능
        Account fromAccount = accountRepository.findById(fromId);
        Account toAccount = accountRepository.findById(toId);
        
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        toAccount.setBalance(toAccount.getBalance().add(amount));
        
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
    }
}
```

### 4.5 사용 사례
```java
// 데이터 일관성이 매우 중요한 작업에 사용
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class CriticalDataService {
    
    public void updateCriticalData(Long id, String newValue) {
        // 모든 동시성 문제가 방지됨
        CriticalData data = criticalDataRepository.findById(id);
        data.setValue(newValue);
        criticalDataRepository.save(data);
    }
    
    public void processFinancialTransaction(FinancialTransaction transaction) {
        // 금융 거래는 데이터 일관성이 매우 중요
        // 모든 동시성 문제를 방지해야 함
        processTransaction(transaction);
    }
}
```

## 5. 격리 수준별 성능 비교

### 5.1 성능 특성
```java
// 성능 테스트 예제
@Service
public class PerformanceTestService {
    
    // READ_UNCOMMITTED - 가장 빠름
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public void readUncommittedTest() {
        // 락 사용량 최소, 동시성 최대
        // 하지만 데이터 일관성 문제 발생 가능
    }
    
    // READ_COMMITTED - 균형점
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void readCommittedTest() {
        // 적절한 락 사용, 적절한 동시성
        // 대부분의 애플리케이션에 적합
    }
    
    // REPEATABLE_READ - 중간
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void repeatableReadTest() {
        // 높은 락 사용, 낮은 동시성
        // 읽기 일관성이 중요한 경우에 사용
    }
    
    // SERIALIZABLE - 가장 느림
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void serializableTest() {
        // 최대 락 사용, 최소 동시성
        // 데이터 일관성이 매우 중요한 경우에만 사용
    }
}
```

### 5.2 동시성 비교
```java
// 동시성 테스트 예제
@Service
public class ConcurrencyTestService {
    
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void concurrentReadCommitted() {
        // 여러 트랜잭션이 동시에 읽기 가능
        // 쓰기 시에만 락
    }
    
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void concurrentRepeatableRead() {
        // 읽기 트랜잭션이 완료될 때까지 다른 트랜잭션 대기
        // 동시성이 낮아짐
    }
    
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void concurrentSerializable() {
        // 트랜잭션이 순차적으로 실행
        // 동시성이 최소
    }
}
```

## 6. 실제 사용 시나리오

### 6.1 읽기 중심 애플리케이션
```java
// 보고서 생성 서비스
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class ReportService {
    
    public Report generateUserReport() {
        // READ_COMMITTED로 충분
        // Dirty Read 방지하면서 성능 유지
        List<User> users = userRepository.findAll();
        return new Report(users);
    }
    
    public Statistics generateStatistics() {
        // 통계 작업에는 READ_COMMITTED가 적합
        long totalUsers = userRepository.count();
        double averageAge = userRepository.getAverageAge();
        return new Statistics(totalUsers, averageAge);
    }
}
```

### 6.2 쓰기 중심 애플리케이션
```java
// 주문 처리 서비스
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class OrderService {
    
    public void processOrder(Order order) {
        // REPEATABLE_READ로 데이터 일관성 보장
        // Lost Update 방지
        
        // 재고 확인
        Product product = productRepository.findById(order.getProductId());
        if (product.getStock() < order.getQuantity()) {
            throw new InsufficientStockException("Insufficient stock");
        }
        
        // 재고 차감
        product.setStock(product.getStock() - order.getQuantity());
        productRepository.save(product);
        
        // 주문 저장
        orderRepository.save(order);
    }
}
```

### 6.3 복잡한 비즈니스 로직
```java
// 금융 거래 서비스
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class FinancialTransactionService {
    
    public void processFinancialTransaction(FinancialTransaction transaction) {
        // SERIALIZABLE로 모든 동시성 문제 방지
        // 금융 거래는 데이터 일관성이 매우 중요
        
        // 계좌 잔액 확인
        Account account = accountRepository.findById(transaction.getAccountId());
        if (account.getBalance().compareTo(transaction.getAmount()) < 0) {
            throw new InsufficientFundsException("Insufficient funds");
        }
        
        // 거래 처리
        account.setBalance(account.getBalance().subtract(transaction.getAmount()));
        accountRepository.save(account);
        
        // 거래 기록 저장
        transactionRepository.save(transaction);
    }
}
```

## 7. 격리 수준 선택 가이드

### 7.1 선택 기준
```java
// 1. 성능이 중요한 경우
@Transactional(isolation = Isolation.READ_COMMITTED)
public class PerformanceCriticalService {
    // READ_COMMITTED 사용
    // Dirty Read 방지하면서 성능 유지
}

// 2. 읽기 일관성이 중요한 경우
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class ConsistencyCriticalService {
    // REPEATABLE_READ 사용
    // Non-Repeatable Read 방지
}

// 3. 데이터 일관성이 매우 중요한 경우
@Transactional(isolation = Isolation.SERIALIZABLE)
public class DataIntegrityCriticalService {
    // SERIALIZABLE 사용
    // 모든 동시성 문제 방지
}

// 4. 통계나 집계 작업
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public class StatisticsService {
    // READ_UNCOMMITTED 사용
    // 정확한 수치가 아니어도 되는 작업
}
```

### 7.2 성능 최적화
```java
// 트랜잭션 범위 최소화
@Service
public class OptimizedService {
    
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void optimizedMethod() {
        // 필요한 작업만 트랜잭션 내에서 실행
        processDatabaseWork();
    }
    
    public void longRunningMethod() {
        // 1. 트랜잭션 작업
        optimizedMethod();
        
        // 2. 외부 API 호출 (트랜잭션 외부)
        callExternalAPI();
        
        // 3. 추가 트랜잭션 작업
        optimizedMethod();
    }
}
```

## 8. 주의사항 및 베스트 프랙티스

### 8.1 데드락 방지
```java
// 잘못된 예: 데드락 발생 가능
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    Account fromAccount = accountRepository.findById(fromId);
    Account toAccount = accountRepository.findById(toId);
    // 데드락 발생 가능
}

// 올바른 예: ID 순서로 정렬하여 데드락 방지
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    if (fromId.compareTo(toId) < 0) {
        Account fromAccount = accountRepository.findById(fromId);
        Account toAccount = accountRepository.findById(toId);
    } else {
        Account toAccount = accountRepository.findById(toId);
        Account fromAccount = accountRepository.findById(fromId);
    }
}
```

### 8.2 적절한 격리 수준 선택
```java
// 기본적으로 READ_COMMITTED 사용
@Transactional(isolation = Isolation.READ_COMMITTED)
public class DefaultService {
    // 대부분의 경우에 적합
}

// 필요한 경우에만 높은 격리 수준 사용
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class SpecialCaseService {
    // 특별한 요구사항이 있는 경우에만
}

// 최후의 수단으로 SERIALIZABLE 사용
@Transactional(isolation = Isolation.SERIALIZABLE)
public class LastResortService {
    // 정말 필요한 경우에만 사용
}
```

이제 다음 학습 자료에서 롤백 정책과 예외 처리에 대해 알아보겠습니다.
