# 트랜잭션 격리 수준(Isolation) 기본 개념

## 1. 트랜잭션 격리 수준이란?

### 정의
트랜잭션 격리 수준(Transaction Isolation Level)은 **동시에 실행되는 여러 트랜잭션들이 서로의 작업에 얼마나 영향을 주고받을지를 제어하는 수준**입니다.

### 왜 필요한가?
```java
// 동시성 문제가 발생할 수 있는 상황
@Service
@Transactional
public class AccountService {
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 1. 출금 계좌 조회
        Account fromAccount = accountRepository.findById(fromAccountId);
        
        // 2. 잔액 확인
        if (fromAccount.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException("Insufficient funds");
        }
        
        // 3. 출금 처리
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        accountRepository.save(fromAccount);
        
        // 4. 입금 계좌 조회
        Account toAccount = accountRepository.findById(toAccountId);
        
        // 5. 입금 처리
        toAccount.setBalance(toAccount.getBalance().add(amount));
        accountRepository.save(toAccount);
    }
}
```

위 코드에서 두 개의 트랜잭션이 동시에 실행되면 다음과 같은 문제가 발생할 수 있습니다:

1. **Dirty Read**: 커밋되지 않은 데이터를 읽음
2. **Non-Repeatable Read**: 같은 쿼리를 반복 실행했을 때 다른 결과
3. **Phantom Read**: 새로운 행이 나타나거나 사라짐
4. **Lost Update**: 동시 업데이트로 인한 데이터 손실

## 2. ACID 속성 중 Isolation

### ACID 속성
- **Atomicity (원자성)**: 트랜잭션의 모든 작업이 성공하거나 모두 실패
- **Consistency (일관성)**: 트랜잭션 실행 후에도 데이터베이스의 무결성 유지
- **Isolation (격리성)**: 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않음
- **Durability (지속성)**: 커밋된 트랜잭션의 결과는 영구적으로 보존

### Isolation의 의미
```java
// 격리성이 없다면 발생할 수 있는 문제
@Service
@Transactional
public class UserService {
    
    public void updateUser(Long userId, String newName) {
        User user = userRepository.findById(userId);
        user.setName(newName);
        // 이 시점에서 다른 트랜잭션이 같은 사용자를 수정할 수 있음
        userRepository.save(user);
    }
}

// 격리성이 있다면
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class UserService {
    
    public void updateUser(Long userId, String newName) {
        User user = userRepository.findById(userId);
        user.setName(newName);
        // 다른 트랜잭션은 이 사용자를 수정할 수 없음 (락에 의해)
        userRepository.save(user);
    }
}
```

## 3. 동시성 문제의 종류

### 3.1 Dirty Read (더티 리드)
**정의**: 커밋되지 않은 데이터를 읽는 문제

**발생 시나리오**:
```java
// 트랜잭션 1
@Transactional
public void updateUser(Long userId, String newName) {
    User user = userRepository.findById(userId);
    user.setName(newName);
    userRepository.save(user);
    // 아직 커밋되지 않음
    // ... 다른 작업들 ...
    // 예외 발생으로 롤백됨
}

// 트랜잭션 2
@Transactional
public void readUser(Long userId) {
    User user = userRepository.findById(userId);
    // 트랜잭션 1이 커밋되지 않은 데이터를 읽음
    System.out.println(user.getName()); // 잘못된 데이터
}
```

**해결 방법**: READ_COMMITTED 이상의 격리 수준 사용

### 3.2 Non-Repeatable Read (반복 불가능 읽기)
**정의**: 같은 쿼리를 반복 실행했을 때 다른 결과가 나오는 문제

**발생 시나리오**:
```java
// 트랜잭션 1
@Transactional
public void readUserTwice(Long userId) {
    User user1 = userRepository.findById(userId);
    System.out.println("First read: " + user1.getName());
    
    // 다른 트랜잭션이 사용자 정보를 수정
    
    User user2 = userRepository.findById(userId);
    System.out.println("Second read: " + user2.getName());
    // user1.getName() != user2.getName()
}

// 트랜잭션 2
@Transactional
public void updateUser(Long userId, String newName) {
    User user = userRepository.findById(userId);
    user.setName(newName);
    userRepository.save(user);
    // 커밋됨
}
```

**해결 방법**: REPEATABLE_READ 이상의 격리 수준 사용

### 3.3 Phantom Read (팬텀 리드)
**정의**: 새로운 행이 나타나거나 사라지는 문제

**발생 시나리오**:
```java
// 트랜잭션 1
@Transactional
public void countUsers() {
    int count1 = userRepository.count();
    System.out.println("First count: " + count1);
    
    // 다른 트랜잭션이 새로운 사용자를 추가
    
    int count2 = userRepository.count();
    System.out.println("Second count: " + count2);
    // count1 != count2
}

// 트랜잭션 2
@Transactional
public void createUser(String name) {
    User user = new User(name);
    userRepository.save(user);
    // 커밋됨
}
```

**해결 방법**: SERIALIZABLE 격리 수준 사용

### 3.4 Lost Update (업데이트 손실)
**정의**: 동시 업데이트로 인한 데이터 손실

**발생 시나리오**:
```java
// 트랜잭션 1
@Transactional
public void incrementCounter(Long counterId) {
    Counter counter = counterRepository.findById(counterId);
    counter.setValue(counter.getValue() + 1);
    counterRepository.save(counter);
}

// 트랜잭션 2
@Transactional
public void incrementCounter(Long counterId) {
    Counter counter = counterRepository.findById(counterId);
    counter.setValue(counter.getValue() + 1);
    counterRepository.save(counter);
}

// 결과: 두 트랜잭션이 모두 +1을 했지만 실제로는 +1만 증가
```

**해결 방법**: 적절한 락 사용 또는 낙관적/비관적 락 사용

## 4. 격리 수준의 4가지 옵션

### 4.1 READ_UNCOMMITTED
**특징**: 가장 낮은 격리 수준, 모든 동시성 문제 발생 가능

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void readUncommittedData() {
    // 커밋되지 않은 데이터도 읽을 수 있음
    // Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능
}
```

**사용 사례**: 성능이 중요하고 데이터 일관성이 덜 중요한 경우

### 4.2 READ_COMMITTED
**특징**: 커밋된 데이터만 읽기, Dirty Read 방지

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readCommittedData() {
    // 커밋된 데이터만 읽음
    // Dirty Read는 방지되지만 Non-Repeatable Read, Phantom Read는 발생 가능
}
```

**사용 사례**: 대부분의 애플리케이션에서 사용하는 기본 격리 수준

### 4.3 REPEATABLE_READ
**특징**: 반복 읽기 일관성 보장, Dirty Read와 Non-Repeatable Read 방지

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void readRepeatableData() {
    // 같은 쿼리를 반복 실행해도 같은 결과
    // Dirty Read와 Non-Repeatable Read는 방지되지만 Phantom Read는 발생 가능
}
```

**사용 사례**: 읽기 일관성이 중요한 경우

### 4.4 SERIALIZABLE
**특징**: 가장 높은 격리 수준, 모든 동시성 문제 방지

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void readSerializableData() {
    // 모든 동시성 문제가 방지됨
    // 성능은 가장 낮지만 데이터 일관성은 가장 높음
}
```

**사용 사례**: 데이터 일관성이 매우 중요한 경우

## 5. 격리 수준별 동시성 문제 발생 여부

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | Lost Update |
|-----------|------------|-------------------|--------------|-------------|
| READ_UNCOMMITTED | 발생 | 발생 | 발생 | 발생 |
| READ_COMMITTED | 방지 | 발생 | 발생 | 발생 |
| REPEATABLE_READ | 방지 | 방지 | 발생 | 방지 |
| SERIALIZABLE | 방지 | 방지 | 방지 | 방지 |

## 6. 락(Lock) 메커니즘

### 6.1 공유 락(Shared Lock)
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readData(Long id) {
    // SELECT 시 공유 락 획득
    User user = userRepository.findById(id);
    // 다른 트랜잭션도 읽기 가능하지만 쓰기는 불가능
}
```

### 6.2 배타 락(Exclusive Lock)
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateData(Long id, String newName) {
    // UPDATE 시 배타 락 획득
    User user = userRepository.findById(id);
    user.setName(newName);
    userRepository.save(user);
    // 다른 트랜잭션은 읽기/쓰기 모두 불가능
}
```

### 6.3 락의 범위
```java
// 행 레벨 락 (Row-level Lock)
@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateUser(Long userId, String newName) {
    User user = userRepository.findById(userId);
    user.setName(newName);
    userRepository.save(user);
    // 해당 행만 락
}

// 테이블 레벨 락 (Table-level Lock)
@Transactional(isolation = Isolation.SERIALIZABLE)
public void updateAllUsers() {
    // 전체 테이블 락
    userRepository.updateAllUsers();
}
```

## 7. 실제 사용 예제

### 7.1 기본 격리 수준 사용
```java
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User findById(Long id) {
        // READ_COMMITTED: 커밋된 데이터만 읽음
        return userRepository.findById(id);
    }
    
    public User updateUser(Long id, String newName) {
        // READ_COMMITTED: 업데이트 시 배타 락 획득
        User user = userRepository.findById(id);
        user.setName(newName);
        return userRepository.save(user);
    }
}
```

### 7.2 높은 격리 수준 사용
```java
@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // REPEATABLE_READ: 반복 읽기 일관성 보장
        Account fromAccount = accountRepository.findById(fromAccountId);
        Account toAccount = accountRepository.findById(toAccountId);
        
        // 같은 쿼리를 반복 실행해도 같은 결과
        if (fromAccount.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException("Insufficient funds");
        }
        
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        toAccount.setBalance(toAccount.getBalance().add(amount));
        
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
    }
}
```

### 7.3 최고 격리 수준 사용
```java
@Service
@Transactional(isolation = Isolation.SERIALIZABLE)
public class CriticalDataService {
    
    @Autowired
    private CriticalDataRepository criticalDataRepository;
    
    public void updateCriticalData(Long id, String newValue) {
        // SERIALIZABLE: 모든 동시성 문제 방지
        // 성능은 낮지만 데이터 일관성은 최고
        CriticalData data = criticalDataRepository.findById(id);
        data.setValue(newValue);
        criticalDataRepository.save(data);
    }
}
```

## 8. 성능과 일관성의 트레이드오프

### 8.1 성능 특성
```java
// 낮은 격리 수준 - 높은 성능, 낮은 일관성
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void highPerformanceMethod() {
    // 락 사용량 최소, 동시성 최대
    // 하지만 데이터 일관성 문제 발생 가능
}

// 높은 격리 수준 - 낮은 성능, 높은 일관성
@Transactional(isolation = Isolation.SERIALIZABLE)
public void highConsistencyMethod() {
    // 락 사용량 최대, 동시성 최소
    // 하지만 데이터 일관성 보장
}
```

### 8.2 적절한 격리 수준 선택
```java
// 읽기 중심 애플리케이션
@Transactional(isolation = Isolation.READ_COMMITTED)
public class ReadHeavyService {
    // READ_COMMITTED로 충분
    // Dirty Read 방지하면서 성능 유지
}

// 쓰기 중심 애플리케이션
@Transactional(isolation = Isolation.REPEATABLE_READ)
public class WriteHeavyService {
    // REPEATABLE_READ로 데이터 일관성 보장
    // Lost Update 방지
}

// 복잡한 비즈니스 로직
@Transactional(isolation = Isolation.SERIALIZABLE)
public class ComplexBusinessService {
    // SERIALIZABLE로 모든 동시성 문제 방지
    // 성능보다 일관성이 중요한 경우
}
```

## 9. 주의사항 및 베스트 프랙티스

### 9.1 데드락 방지
```java
// 잘못된 예: 데드락 발생 가능
@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    Account fromAccount = accountRepository.findById(fromId);
    Account toAccount = accountRepository.findById(toId);
    // 데드락 발생 가능
}

// 올바른 예: ID 순서로 정렬하여 데드락 방지
@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    if (fromId.compareTo(toId) < 0) {
        Account fromAccount = accountRepository.findById(fromId);
        Account toAccount = accountRepository.findById(toId);
    } else {
        Account toAccount = accountRepository.findById(toId);
        Account fromAccount = accountRepository.findById(fromId);
    }
}
```

### 9.2 트랜잭션 범위 최소화
```java
// 잘못된 예: 긴 트랜잭션
@Transactional(isolation = Isolation.SERIALIZABLE)
public void longRunningMethod() {
    // 1. 데이터베이스 작업
    processDatabaseWork();
    
    // 2. 외부 API 호출 (시간이 오래 걸림)
    callExternalAPI();
    
    // 3. 추가 데이터베이스 작업
    processMoreDatabaseWork();
}

// 올바른 예: 트랜잭션 분리
@Transactional(isolation = Isolation.SERIALIZABLE)
public void optimizedMethod() {
    // 1. 데이터베이스 작업
    processDatabaseWork();
}

public void longRunningMethod() {
    // 1. 트랜잭션 작업
    optimizedMethod();
    
    // 2. 외부 API 호출 (트랜잭션 외부)
    callExternalAPI();
    
    // 3. 추가 트랜잭션 작업
    optimizedMethod();
}
```

이제 다음 학습 자료에서 각 격리 수준의 상세한 동작 원리를 알아보겠습니다.
