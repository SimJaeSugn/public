# 2단계 연습문제 해답: 트랜잭션 전파(Propagation) 동작 원리

## 문제 1: 전파 옵션 기본 이해 (15점)

### 문제
다음 코드에서 각 메서드가 어떤 전파 옵션을 사용하고 있는지 분석하고, 호출 순서에 따른 트랜잭션 동작을 설명하세요.

### 답안
```
1. OrderService.processOrder(): 
   전파 옵션: @Transactional (기본값 = REQUIRED)
   동작: 새로운 트랜잭션을 시작

2. UserService.validateUser(): 
   전파 옵션: Propagation.REQUIRED
   동작: OrderService의 기존 트랜잭션에 참여

3. PaymentService.processPayment(): 
   전파 옵션: Propagation.REQUIRES_NEW
   동작: OrderService의 트랜잭션을 일시 중단하고 새로운 트랜잭션 시작

4. LogService.logOrder(): 
   전파 옵션: Propagation.NOT_SUPPORTED
   동작: OrderService의 트랜잭션을 일시 중단하고 트랜잭션 없이 실행

5. LogService.logError(): 
   전파 옵션: Propagation.NOT_SUPPORTED
   동작: OrderService의 트랜잭션을 일시 중단하고 트랜잭션 없이 실행

전체 호출 순서와 트랜잭션 동작:
1. OrderService.processOrder() 시작 → 트랜잭션 1 시작
2. UserService.validateUser() 호출 → 트랜잭션 1에 참여
3. PaymentService.processPayment() 호출 → 트랜잭션 1 일시 중단, 트랜잭션 2 시작
4. PaymentService.processPayment() 완료 → 트랜잭션 2 커밋, 트랜잭션 1 재개
5. LogService.logOrder() 호출 → 트랜잭션 1 일시 중단, 트랜잭션 없이 실행
6. LogService.logOrder() 완료 → 트랜잭션 1 재개
7. OrderService.processOrder() 완료 → 트랜잭션 1 커밋
```

---

## 문제 2: 전파 옵션별 동작 분석 (20점)

### 답안
```
시나리오 1 (기존 트랜잭션 있음):

REQUIRED: 
- 기존 트랜잭션에 참여
- 별도의 트랜잭션을 생성하지 않음
- 기존 트랜잭션과 함께 커밋/롤백

REQUIRES_NEW: 
- 기존 트랜잭션을 일시 중단
- 새로운 트랜잭션을 생성
- 독립적으로 커밋/롤백

SUPPORTS: 
- 기존 트랜잭션에 참여
- 별도의 트랜잭션을 생성하지 않음
- 기존 트랜잭션과 함께 커밋/롤백

NOT_SUPPORTED: 
- 기존 트랜잭션을 일시 중단
- 트랜잭션 없이 실행
- 기존 트랜잭션은 일시 중단 상태

MANDATORY: 
- 기존 트랜잭션에 참여
- 별도의 트랜잭션을 생성하지 않음
- 기존 트랜잭션과 함께 커밋/롤백

NEVER: 
- IllegalTransactionStateException 발생
- 기존 트랜잭션이 있으면 실행 불가

NESTED: 
- 중첩 트랜잭션 생성 (저장점 사용)
- 부분 롤백 가능
- 기존 트랜잭션과 독립적으로 롤백 가능

시나리오 2 (기존 트랜잭션 없음):

REQUIRED: 
- 새로운 트랜잭션을 생성
- 독립적으로 커밋/롤백

REQUIRES_NEW: 
- 새로운 트랜잭션을 생성
- 독립적으로 커밋/롤백

SUPPORTS: 
- 트랜잭션 없이 실행
- 커밋/롤백 없음

NOT_SUPPORTED: 
- 트랜잭션 없이 실행
- 커밋/롤백 없음

MANDATORY: 
- IllegalTransactionStateException 발생
- 기존 트랜잭션이 없으면 실행 불가

NEVER: 
- 트랜잭션 없이 실행
- 커밋/롤백 없음

NESTED: 
- 새로운 트랜잭션을 생성
- 독립적으로 커밋/롤백
```

---

## 문제 3: 실제 코드 구현 (25점)

### 답안
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private LogService logService;
    
    @Autowired
    private AuditService auditService;
    
    public void processOrder(Order order) {
        try {
            // 1. 사용자 검증 (REQUIRED - 트랜잭션에 참여)
            userService.validateUser(order.getUserId());
            
            // 2. 주문 저장 (REQUIRED - 같은 트랜잭션)
            orderRepository.save(order);
            
            // 3. 재고 차감 (NESTED - 중첩 트랜잭션, 부분 롤백 가능)
            inventoryService.updateStock(order);
            
            // 4. 결제 처리 (REQUIRES_NEW - 독립적인 트랜잭션)
            paymentService.processPayment(order);
            
            // 5. 이메일 발송 (NOT_SUPPORTED - 트랜잭션 없이 실행)
            emailService.sendOrderConfirmation(order);
            
            // 6. 로그 기록 (NOT_SUPPORTED - 트랜잭션 없이 실행)
            logService.logOrderProcess(order);
            
            // 7. 감사 로그 (MANDATORY - 트랜잭션 필수)
            auditService.logOrderProcess(order);
            
        } catch (InventoryException e) {
            // 재고 부족 - 중첩 트랜잭션만 롤백
            logService.logError("Insufficient inventory", e);
            throw e;
            
        } catch (PaymentException e) {
            // 결제 실패 - 독립적인 트랜잭션이므로 이미 롤백됨
            logService.logError("Payment failed", e);
            throw e;
            
        } catch (Exception e) {
            // 기타 예외 - 전체 롤백
            logService.logError("Order processing failed", e);
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRED)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void validateUser(Long userId) {
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new UserNotFoundException("User not found: " + userId);
        }
    }
}

@Service
@Transactional(propagation = Propagation.NESTED)
public class InventoryService {
    
    @Autowired
    private InventoryRepository inventoryRepository;
    
    public void updateStock(Order order) {
        for (OrderItem item : order.getItems()) {
            Product product = inventoryRepository.findById(item.getProductId());
            if (product.getStock() < item.getQuantity()) {
                throw new InventoryException("Insufficient stock for product: " + product.getName());
            }
            product.setStock(product.getStock() - item.getQuantity());
            inventoryRepository.save(product);
        }
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class PaymentService {
    
    @Autowired
    private PaymentRepository paymentRepository;
    
    public void processPayment(Order order) {
        Payment payment = new Payment(order.getId(), order.getAmount());
        paymentRepository.processPayment(payment);
        
        // 결제 처리 로직
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new PaymentException("Invalid payment amount");
        }
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class EmailService {
    
    @Autowired
    private EmailRepository emailRepository;
    
    public void sendOrderConfirmation(Order order) {
        Email email = new Email(order.getCustomerEmail(), "Order Confirmation");
        emailRepository.sendEmail(email);
        // 실제 이메일 발송 로직
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class LogService {
    
    @Autowired
    private LogRepository logRepository;
    
    public void logOrderProcess(Order order) {
        LogEntry logEntry = new LogEntry("ORDER_PROCESSED", order.getId());
        logRepository.saveLog(logEntry);
    }
    
    public void logError(String message, Exception e) {
        LogEntry logEntry = new LogEntry("ERROR", message, e.getMessage());
        logRepository.saveLog(logEntry);
    }
}

@Service
@Transactional(propagation = Propagation.MANDATORY)
public class AuditService {
    
    @Autowired
    private AuditRepository auditRepository;
    
    public void logOrderProcess(Order order) {
        AuditEntry auditEntry = new AuditEntry("ORDER_PROCESSED", order.getId());
        auditRepository.saveAudit(auditEntry);
    }
}
```

---

## 문제 4: 전파 옵션 선택 전략 (20점)

### 답안
```
상황 1: 이메일 발송
선택한 전파 옵션: REQUIRES_NEW
이유: 
- 이메일 발송은 주문 처리와 독립적으로 실행되어야 함
- 이메일 발송 실패해도 주문 처리는 성공해야 함
- 이메일 발송은 별도의 트랜잭션에서 실행되어야 함

상황 2: 재고 차감
선택한 전파 옵션: NESTED
이유: 
- 재고 차감 실패 시 부분 롤백이 가능해야 함
- 주문은 저장되고 재고 차감만 롤백되어야 함
- 중첩 트랜잭션을 사용하여 부분 롤백 구현

상황 3: 사용자 조회
선택한 전파 옵션: SUPPORTS
이유: 
- 트랜잭션과 함께 호출되면 트랜잭션에 참여
- 트랜잭션 없이 호출되면 트랜잭션 없이 실행
- 읽기 전용 작업이므로 유연한 트랜잭션 처리 가능
```

---

## 문제 5: 전파 옵션 디버깅 (20점)

### 답안
```
발견된 문제점:

1. LogService.logOrder() 메서드
   문제: Propagation.NEVER로 설정되어 있는데 트랜잭션과 함께 호출됨
   해결방안: Propagation.NOT_SUPPORTED로 변경하여 트랜잭션을 일시 중단하고 실행

2. LogService.logError() 메서드
   문제: Propagation.NEVER로 설정되어 있는데 트랜잭션과 함께 호출됨
   해결방안: Propagation.NOT_SUPPORTED로 변경하여 트랜잭션을 일시 중단하고 실행

3. 예외 처리 로직
   문제: logService.logError()가 트랜잭션과 함께 호출되어 예외 발생
   해결방안: 로그 서비스를 별도 스레드에서 실행하거나 전파 옵션 변경

수정된 코드:
```

```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            userService.validateUser(order.getUserId());
            paymentService.processPayment(order);
            logService.logOrder(order);
        } catch (Exception e) {
            // 비동기로 로그 기록 (트랜잭션과 분리)
            CompletableFuture.runAsync(() -> {
                logService.logError("Order processing failed", e);
            });
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.MANDATORY)
public class UserService {
    public void validateUser(Long userId) { }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class PaymentService {
    public void processPayment(Order order) { }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class LogService {
    public void logOrder(Order order) { }
    public void logError(String message, Exception e) { }
}
```

**추가 해결방안:**
```java
// 대안 1: 로그 서비스를 별도 스레드에서 실행
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 비즈니스 로직
            processBusinessLogic(order);
        } catch (Exception e) {
            // 비동기로 로그 기록
            CompletableFuture.runAsync(() -> {
                logService.logError("Order processing failed", e);
            });
            throw e;
        }
    }
}

// 대안 2: 트랜잭션 동기화 사용
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        // 트랜잭션 동기화 등록
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    logService.logOrder(order);
                }
                
                @Override
                public void afterRollback() {
                    logService.logError("Order processing failed", null);
                }
            }
        );
        
        try {
            // 비즈니스 로직
            processBusinessLogic(order);
        } catch (Exception e) {
            throw e;
        }
    }
}
```

---

## 추가 학습 포인트

### 1. 전파 옵션 선택 기준
- **REQUIRED**: 일반적인 비즈니스 로직
- **REQUIRES_NEW**: 독립적인 작업 (로깅, 알림)
- **SUPPORTS**: 선택적 트랜잭션 (읽기 작업)
- **NOT_SUPPORTED**: 트랜잭션과 무관한 작업
- **MANDATORY**: 트랜잭션 필수 작업
- **NEVER**: 트랜잭션 금지 작업
- **NESTED**: 부분 롤백 가능한 작업

### 2. 성능 고려사항
- **REQUIRES_NEW**: 새로운 트랜잭션 생성으로 인한 성능 오버헤드
- **NOT_SUPPORTED**: 기존 트랜잭션 일시 중단으로 인한 성능 영향
- **NESTED**: 저장점 사용으로 인한 메모리 사용량 증가

### 3. 실무 적용 시 주의사항
- 전파 옵션을 명확히 이해하고 적절히 선택
- 복잡한 비즈니스 로직에서는 전파 전략을 문서화
- 성능 테스트를 통한 전파 옵션 검증
- 예외 처리와 전파 옵션의 관계 고려
