# 트랜잭션 전파(Propagation) 기본 개념

## 1. 트랜잭션 전파란?

### 정의
트랜잭션 전파(Transaction Propagation)는 **하나의 트랜잭션 메서드가 다른 트랜잭션 메서드를 호출할 때, 새로운 트랜잭션을 생성할지 아니면 기존 트랜잭션에 참여할지를 결정하는 메커니즘**입니다.

### 왜 필요한가?
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private PaymentService paymentService;
    
    public void processOrder(Order order) {
        // 1. 사용자 검증
        userService.validateUser(order.getUserId());
        
        // 2. 결제 처리
        paymentService.processPayment(order);
        
        // 3. 주문 저장
        saveOrder(order);
    }
}
```

위 코드에서 `processOrder`는 트랜잭션 메서드이고, 내부에서 `userService.validateUser()`와 `paymentService.processPayment()`를 호출합니다. 이때 각 메서드가 어떻게 트랜잭션을 처리할지 결정해야 합니다.

## 2. 트랜잭션 전파의 필요성

### 2.1 데이터 일관성 보장
```java
// 잘못된 예: 각각 독립적인 트랜잭션
@Transactional
public void processOrder(Order order) {
    userService.validateUser(order.getUserId()); // 트랜잭션 1
    paymentService.processPayment(order);        // 트랜잭션 2
    saveOrder(order);                            // 트랜잭션 3
}

// 만약 paymentService에서 예외가 발생하면?
// - userService의 변경사항은 커밋됨
// - saveOrder는 실행되지 않음
// - 데이터 일관성 깨짐!
```

### 2.2 성능 최적화
```java
// 모든 작업을 하나의 트랜잭션에서 처리
@Transactional
public void processOrder(Order order) {
    userService.validateUser(order.getUserId());     // 같은 트랜잭션
    paymentService.processPayment(order);            // 같은 트랜잭션
    saveOrder(order);                                // 같은 트랜잭션
}
```

### 2.3 유연한 트랜잭션 관리
```java
// 로깅은 트랜잭션과 무관하게 실행
@Transactional
public void processOrder(Order order) {
    try {
        // 비즈니스 로직
        processBusinessLogic(order);
    } finally {
        // 로깅은 별도 트랜잭션에서 실행
        logService.logOrderProcess(order);
    }
}
```

## 3. 트랜잭션 컨텍스트 관리

### 3.1 트랜잭션 상태 추적
```java
// TransactionSynchronizationManager를 통한 상태 관리
public class TransactionSynchronizationManager {
    
    // 현재 스레드의 트랜잭션 상태
    private static final ThreadLocal<TransactionStatus> currentTransaction = new ThreadLocal<>();
    
    // 트랜잭션 활성화 여부 확인
    public static boolean isActualTransactionActive() {
        TransactionStatus status = currentTransaction.get();
        return status != null && !status.isCompleted();
    }
    
    // 현재 트랜잭션 상태 조회
    public static TransactionStatus getCurrentTransactionStatus() {
        return currentTransaction.get();
    }
}
```

### 3.2 트랜잭션 스택 관리
```java
// 중첩된 트랜잭션 호출 시 스택 관리
public class TransactionStack {
    
    private Stack<TransactionStatus> transactionStack = new Stack<>();
    
    // 새로운 트랜잭션 시작
    public void pushTransaction(TransactionStatus status) {
        transactionStack.push(status);
    }
    
    // 트랜잭션 종료
    public TransactionStatus popTransaction() {
        return transactionStack.pop();
    }
    
    // 현재 트랜잭션 조회
    public TransactionStatus getCurrentTransaction() {
        return transactionStack.isEmpty() ? null : transactionStack.peek();
    }
}
```

## 4. 전파 옵션 개요

### 4.1 7가지 전파 옵션
```java
public enum Propagation {
    REQUIRED,        // 기본값, 기존 트랜잭션 참여 또는 새로 생성
    REQUIRES_NEW,    // 항상 새로운 트랜잭션 생성
    SUPPORTS,        // 기존 트랜잭션이 있으면 참여, 없으면 트랜잭션 없이 실행
    NOT_SUPPORTED,   // 트랜잭션 없이 실행, 기존 트랜잭션 일시 중단
    MANDATORY,       // 기존 트랜잭션이 있어야 함, 없으면 예외 발생
    NEVER,           // 트랜잭션 없이 실행, 기존 트랜잭션이 있으면 예외 발생
    NESTED           // 중첩 트랜잭션 생성 (저장점 사용)
}
```

### 4.2 전파 옵션 선택 기준
```java
// 1. REQUIRED: 일반적인 경우
@Transactional(propagation = Propagation.REQUIRED)
public void normalBusinessMethod() {
    // 대부분의 비즈니스 로직에 적합
}

// 2. REQUIRES_NEW: 독립적인 작업
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void independentOperation() {
    // 로깅, 알림 등 독립적으로 실행되어야 하는 작업
}

// 3. SUPPORTS: 선택적 트랜잭션
@Transactional(propagation = Propagation.SUPPORTS)
public void optionalTransactionalMethod() {
    // 트랜잭션이 있으면 참여, 없으면 그냥 실행
}

// 4. NOT_SUPPORTED: 트랜잭션 비활성화
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void nonTransactionalMethod() {
    // 트랜잭션과 무관하게 실행되어야 하는 작업
}

// 5. MANDATORY: 트랜잭션 필수
@Transactional(propagation = Propagation.MANDATORY)
public void mandatoryTransactionalMethod() {
    // 반드시 트랜잭션 컨텍스트에서 실행되어야 하는 작업
}

// 6. NEVER: 트랜잭션 금지
@Transactional(propagation = Propagation.NEVER)
public void neverTransactionalMethod() {
    // 트랜잭션 없이 실행되어야 하는 작업
}

// 7. NESTED: 중첩 트랜잭션
@Transactional(propagation = Propagation.NESTED)
public void nestedTransactionalMethod() {
    // 부분 롤백이 가능한 중첩 트랜잭션
}
```

## 5. 전파 메커니즘의 내부 동작

### 5.1 트랜잭션 시작 결정
```java
// AbstractPlatformTransactionManager.getTransaction()
public TransactionStatus getTransaction(TransactionDefinition definition) {
    // 1. 기존 트랜잭션 확인
    Object transaction = doGetTransaction();
    
    if (isExistingTransaction(transaction)) {
        // 기존 트랜잭션이 있는 경우
        return handleExistingTransaction(definition, transaction);
    } else {
        // 기존 트랜잭션이 없는 경우
        return startNewTransaction(definition, transaction);
    }
}

private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    // 전파 옵션에 따른 처리
    switch (definition.getPropagationBehavior()) {
        case REQUIRED:
            // 기존 트랜잭션에 참여
            return new DefaultTransactionStatus(transaction, false, false, false, true, null);
            
        case REQUIRES_NEW:
            // 기존 트랜잭션 일시 중단하고 새로운 트랜잭션 시작
            return startNewTransaction(definition, transaction);
            
        case SUPPORTS:
            // 기존 트랜잭션에 참여
            return new DefaultTransactionStatus(transaction, false, false, false, true, null);
            
        case NOT_SUPPORTED:
            // 기존 트랜잭션 일시 중단하고 트랜잭션 없이 실행
            return new DefaultTransactionStatus(null, false, false, false, true, transaction);
            
        case MANDATORY:
            // 기존 트랜잭션에 참여
            return new DefaultTransactionStatus(transaction, false, false, false, true, null);
            
        case NEVER:
            // 예외 발생
            throw new IllegalTransactionStateException("Existing transaction found for NEVER propagation");
            
        case NESTED:
            // 중첩 트랜잭션 생성
            return createNestedTransaction(definition, transaction);
    }
}
```

### 5.2 롤백 전파 메커니즘
```java
// 트랜잭션 롤백 시 전파 처리
public void rollback(TransactionStatus status) {
    if (status.isRollbackOnly()) {
        // 이미 롤백 마킹된 상태
        doRollback(status);
    } else if (status.isNewTransaction()) {
        // 새로운 트랜잭션인 경우
        doRollback(status);
    } else {
        // 기존 트랜잭션에 참여한 경우
        // 최상위 트랜잭션에 롤백 마킹
        status.setRollbackOnly();
    }
}
```

## 6. 실제 사용 예제

### 6.1 기본 전파 예제
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 1. 사용자 검증 (REQUIRED - 같은 트랜잭션)
            userService.validateUser(order.getUserId());
            
            // 2. 결제 처리 (REQUIRED - 같은 트랜잭션)
            paymentService.processPayment(order);
            
            // 3. 주문 저장 (REQUIRED - 같은 트랜잭션)
            saveOrder(order);
            
        } catch (Exception e) {
            // 4. 로깅 (REQUIRES_NEW - 독립적인 트랜잭션)
            logService.logError("Order processing failed", e);
            throw e;
        }
    }
    
    private void saveOrder(Order order) {
        // 주문 저장 로직
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class LogService {
    
    public void logError(String message, Exception e) {
        // 로깅은 독립적인 트랜잭션에서 실행
        // 주문 처리 실패와 관계없이 로그는 저장됨
    }
}
```

### 6.2 복잡한 전파 시나리오
```java
@Service
@Transactional
public class ComplexBusinessService {
    
    @Autowired
    private DataService dataService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AuditService auditService;
    
    public void complexBusinessProcess(BusinessData data) {
        // 1. 데이터 검증 (REQUIRED)
        dataService.validateData(data);
        
        // 2. 비즈니스 로직 실행 (REQUIRED)
        processBusinessLogic(data);
        
        // 3. 알림 발송 (REQUIRES_NEW)
        try {
            notificationService.sendNotification(data);
        } catch (Exception e) {
            // 알림 실패해도 메인 트랜잭션은 계속 진행
            log.warn("Notification failed", e);
        }
        
        // 4. 감사 로그 (REQUIRES_NEW)
        auditService.logBusinessProcess(data);
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class NotificationService {
    
    public void sendNotification(BusinessData data) {
        // 독립적인 트랜잭션에서 실행
        // 메인 트랜잭션과 무관하게 실행됨
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class AuditService {
    
    public void logBusinessProcess(BusinessData data) {
        // 독립적인 트랜잭션에서 실행
        // 메인 트랜잭션과 무관하게 실행됨
    }
}
```

## 7. 주의사항 및 베스트 프랙티스

### 7.1 성능 고려사항
```java
// 잘못된 예: 불필요한 REQUIRES_NEW 사용
@Transactional
public void processOrder(Order order) {
    // 모든 작업을 REQUIRES_NEW로 설정하면 성능 저하
    userService.validateUser(order.getUserId());     // REQUIRES_NEW
    paymentService.processPayment(order);            // REQUIRES_NEW
    saveOrder(order);                                // REQUIRES_NEW
}

// 올바른 예: 적절한 전파 옵션 사용
@Transactional
public void processOrder(Order order) {
    userService.validateUser(order.getUserId());     // REQUIRED
    paymentService.processPayment(order);            // REQUIRED
    saveOrder(order);                                // REQUIRED
    
    // 독립적으로 실행되어야 하는 작업만 REQUIRES_NEW
    logService.logOrderProcess(order);               // REQUIRES_NEW
}
```

### 7.2 데드락 방지
```java
// 데드락 위험이 있는 코드
@Transactional
public void transferMoney(Account from, Account to, BigDecimal amount) {
    // 계좌 A에서 B로 이체
    from.debit(amount);
    to.credit(amount);
}

// 데드락 방지 전략
@Transactional
public void transferMoney(Account from, Account to, BigDecimal amount) {
    // 계좌 ID 순서로 정렬하여 데드락 방지
    if (from.getId().compareTo(to.getId()) < 0) {
        from.debit(amount);
        to.credit(amount);
    } else {
        to.credit(amount);
        from.debit(amount);
    }
}
```

### 7.3 메모리 사용량 고려
```java
// 중첩된 트랜잭션 스택 관리
@Transactional
public void level1() {
    level2();
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void level2() {
    level3();
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void level3() {
    // 깊은 중첩은 메모리 사용량 증가
    // 적절한 레벨에서 트랜잭션 종료 필요
}
```

이제 다음 학습 자료에서 각 전파 옵션의 상세한 동작 원리를 알아보겠습니다.
