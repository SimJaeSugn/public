# 7가지 트랜잭션 전파 옵션 상세 분석

## 1. REQUIRED (기본값)

### 1.1 동작 원리
- **기존 트랜잭션이 있으면 참여**, 없으면 새로운 트랜잭션 생성
- 가장 일반적으로 사용되는 전파 옵션
- 기본값이므로 명시적으로 지정하지 않아도 됨

### 1.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    public void processOrder(Order order) {
        // 1. OrderService.processOrder() - 새로운 트랜잭션 시작
        userService.validateUser(order.getUserId()); // 2. 기존 트랜잭션에 참여
        saveOrder(order); // 3. 기존 트랜잭션에 참여
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRED)
public class UserService {
    
    public void validateUser(Long userId) {
        // OrderService의 트랜잭션에 참여
        // 별도의 트랜잭션을 생성하지 않음
    }
}
```

### 1.3 내부 동작 과정
```java
// AbstractPlatformTransactionManager.getTransaction()
public TransactionStatus getTransaction(TransactionDefinition definition) {
    Object transaction = doGetTransaction();
    
    if (isExistingTransaction(transaction)) {
        // 기존 트랜잭션이 있는 경우
        return new DefaultTransactionStatus(
            transaction,    // 기존 트랜잭션 객체
            false,          // 새로운 트랜잭션이 아님
            false,          // 새로운 동기화가 아님
            false,          // 읽기 전용이 아님
            true,           // 실제 트랜잭션
            null            // 일시 중단된 리소스 없음
        );
    } else {
        // 기존 트랜잭션이 없는 경우
        return startNewTransaction(definition, transaction);
    }
}
```

### 1.4 사용 예제
```java
@Service
@Transactional
public class AccountService {
    
    @Autowired
    private TransactionService transactionService;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // 1. 계좌 이체 트랜잭션 시작
        Account fromAccount = getAccount(fromAccountId);
        Account toAccount = getAccount(toAccountId);
        
        // 2. 출금 처리 (같은 트랜잭션)
        fromAccount.debit(amount);
        
        // 3. 입금 처리 (같은 트랜잭션)
        toAccount.credit(amount);
        
        // 4. 거래 기록 저장 (같은 트랜잭션)
        transactionService.recordTransaction(fromAccountId, toAccountId, amount);
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRED)
public class TransactionService {
    
    public void recordTransaction(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // AccountService의 트랜잭션에 참여
        // 별도의 트랜잭션을 생성하지 않음
        Transaction transaction = new Transaction(fromAccountId, toAccountId, amount);
        transactionRepository.save(transaction);
    }
}
```

## 2. REQUIRES_NEW

### 2.1 동작 원리
- **항상 새로운 트랜잭션을 생성**
- 기존 트랜잭션이 있으면 일시 중단하고 새로운 트랜잭션 시작
- 새로운 트랜잭션은 기존 트랜잭션과 독립적으로 동작

### 2.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 1. OrderService.processOrder() - 트랜잭션 1 시작
            saveOrder(order);
            
            // 2. LogService.logOrder() - 트랜잭션 1 일시 중단, 트랜잭션 2 시작
            logService.logOrder(order);
            
            // 3. 트랜잭션 2 커밋, 트랜잭션 1 재개
            updateOrderStatus(order);
            
        } catch (Exception e) {
            // 4. 트랜잭션 1 롤백, 트랜잭션 2는 이미 커밋됨
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class LogService {
    
    public void logOrder(Order order) {
        // 독립적인 트랜잭션에서 실행
        // OrderService의 트랜잭션과 무관하게 동작
        LogEntry logEntry = new LogEntry("Order processed", order.getId());
        logRepository.save(logEntry);
    }
}
```

### 2.3 내부 동작 과정
```java
// AbstractPlatformTransactionManager.getTransaction()
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    if (definition.getPropagationBehavior() == Propagation.REQUIRES_NEW) {
        // 1. 기존 트랜잭션 일시 중단
        Object suspendedResources = suspend(transaction);
        
        try {
            // 2. 새로운 트랜잭션 시작
            return startNewTransaction(definition, transaction);
        } catch (Exception e) {
            // 3. 예외 발생 시 일시 중단된 트랜잭션 복구
            resume(transaction, suspendedResources);
            throw e;
        }
    }
}

private Object suspend(Object transaction) {
    // 1. 현재 트랜잭션 동기화 정리
    TransactionSynchronizationManager.clear();
    
    // 2. 트랜잭션 리소스 일시 중단
    return doSuspend(transaction);
}

private void resume(Object transaction, Object suspendedResources) {
    // 1. 일시 중단된 트랜잭션 복구
    doResume(transaction, suspendedResources);
    
    // 2. 트랜잭션 동기화 복구
    TransactionSynchronizationManager.initSynchronization();
}
```

### 2.4 사용 예제
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private AuditService auditService;
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 처리 (메인 트랜잭션)
            saveOrder(order);
            updateInventory(order);
            
            // 2. 이메일 발송 (독립적인 트랜잭션)
            emailService.sendOrderConfirmation(order);
            
            // 3. 감사 로그 (독립적인 트랜잭션)
            auditService.logOrderProcess(order);
            
        } catch (Exception e) {
            // 주문 처리 실패해도 이메일과 감사 로그는 이미 커밋됨
            log.error("Order processing failed", e);
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class EmailService {
    
    public void sendOrderConfirmation(Order order) {
        // 독립적인 트랜잭션에서 실행
        // 주문 처리 실패와 관계없이 이메일은 발송됨
        Email email = new Email(order.getCustomerEmail(), "Order Confirmation");
        emailRepository.save(email);
        // 실제 이메일 발송 로직
    }
}
```

## 3. SUPPORTS

### 3.1 동작 원리
- **기존 트랜잭션이 있으면 참여**, 없으면 트랜잭션 없이 실행
- 트랜잭션의 존재 여부에 따라 동작이 달라짐
- 읽기 전용 작업에 주로 사용

### 3.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    public void processOrder(Order order) {
        // 1. OrderService.processOrder() - 트랜잭션 시작
        userService.validateUser(order.getUserId()); // 2. 기존 트랜잭션에 참여
        saveOrder(order);
    }
}

@Service
@Transactional(propagation = Propagation.SUPPORTS)
public class UserService {
    
    public void validateUser(Long userId) {
        // OrderService의 트랜잭션에 참여
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new UserNotFoundException("User not found");
        }
    }
    
    public User getUserById(Long userId) {
        // 트랜잭션 없이 호출되면 트랜잭션 없이 실행
        // 트랜잭션과 함께 호출되면 트랜잭션에 참여
        return userRepository.findById(userId);
    }
}
```

### 3.3 내부 동작 과정
```java
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    if (definition.getPropagationBehavior() == Propagation.SUPPORTS) {
        if (isExistingTransaction(transaction)) {
            // 기존 트랜잭션이 있으면 참여
            return new DefaultTransactionStatus(transaction, false, false, false, true, null);
        } else {
            // 기존 트랜잭션이 없으면 트랜잭션 없이 실행
            return new DefaultTransactionStatus(null, false, false, false, false, null);
        }
    }
}
```

### 3.4 사용 예제
```java
@Service
@Transactional(propagation = Propagation.SUPPORTS)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User findById(Long id) {
        // 트랜잭션 없이 호출되면 트랜잭션 없이 실행
        // 트랜잭션과 함께 호출되면 트랜잭션에 참여
        return userRepository.findById(id);
    }
    
    public List<User> findAll() {
        // 읽기 전용 작업에 적합
        return userRepository.findAll();
    }
}

// 사용 예제
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    public void processOrder(Order order) {
        // 트랜잭션과 함께 호출 - userService는 트랜잭션에 참여
        User user = userService.findById(order.getUserId());
        // ...
    }
}

@Service
public class ReportService {
    
    @Autowired
    private UserService userService;
    
    public void generateReport() {
        // 트랜잭션 없이 호출 - userService는 트랜잭션 없이 실행
        List<User> users = userService.findAll();
        // ...
    }
}
```

## 4. NOT_SUPPORTED

### 4.1 동작 원리
- **트랜잭션 없이 실행**
- 기존 트랜잭션이 있으면 일시 중단하고 트랜잭션 없이 실행
- 트랜잭션과 무관하게 실행되어야 하는 작업에 사용

### 4.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 1. OrderService.processOrder() - 트랜잭션 시작
            saveOrder(order);
            
            // 2. LogService.logOrder() - 트랜잭션 일시 중단, 트랜잭션 없이 실행
            logService.logOrder(order);
            
            // 3. 트랜잭션 재개
            updateOrderStatus(order);
            
        } catch (Exception e) {
            // 4. 트랜잭션 롤백
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class LogService {
    
    public void logOrder(Order order) {
        // 트랜잭션 없이 실행
        // OrderService의 트랜잭션과 무관하게 동작
        LogEntry logEntry = new LogEntry("Order processed", order.getId());
        logRepository.save(logEntry);
    }
}
```

### 4.3 내부 동작 과정
```java
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    if (definition.getPropagationBehavior() == Propagation.NOT_SUPPORTED) {
        if (isExistingTransaction(transaction)) {
            // 기존 트랜잭션 일시 중단
            Object suspendedResources = suspend(transaction);
            return new DefaultTransactionStatus(null, false, false, false, false, suspendedResources);
        } else {
            // 트랜잭션 없이 실행
            return new DefaultTransactionStatus(null, false, false, false, false, null);
        }
    }
}
```

### 4.4 사용 예제
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 처리 (트랜잭션)
            saveOrder(order);
            updateInventory(order);
            
            // 2. 이메일 발송 (트랜잭션 없이)
            emailService.sendOrderConfirmation(order);
            
            // 3. 로그 기록 (트랜잭션 없이)
            logService.logOrderProcess(order);
            
        } catch (Exception e) {
            // 주문 처리 실패해도 이메일과 로그는 이미 처리됨
            log.error("Order processing failed", e);
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class EmailService {
    
    public void sendOrderConfirmation(Order order) {
        // 트랜잭션 없이 실행
        // 주문 처리 실패와 관계없이 이메일은 발송됨
        Email email = new Email(order.getCustomerEmail(), "Order Confirmation");
        emailRepository.save(email);
        // 실제 이메일 발송 로직
    }
}
```

## 5. MANDATORY

### 5.1 동작 원리
- **기존 트랜잭션이 있어야 함**, 없으면 예외 발생
- 트랜잭션 컨텍스트에서만 실행되어야 하는 작업에 사용
- 잘못된 호출을 방지하는 안전장치 역할

### 5.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    public void processOrder(Order order) {
        // 1. OrderService.processOrder() - 트랜잭션 시작
        userService.validateUser(order.getUserId()); // 2. 기존 트랜잭션에 참여
        saveOrder(order);
    }
}

@Service
@Transactional(propagation = Propagation.MANDATORY)
public class UserService {
    
    public void validateUser(Long userId) {
        // OrderService의 트랜잭션에 참여
        User user = userRepository.findById(userId);
        if (user == null) {
            throw new UserNotFoundException("User not found");
        }
    }
}

// 잘못된 사용 예제
@Service
public class ReportService {
    
    @Autowired
    private UserService userService;
    
    public void generateReport() {
        // 트랜잭션 없이 호출 - IllegalTransactionStateException 발생!
        userService.validateUser(1L);
    }
}
```

### 5.3 내부 동작 과정
```java
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    if (definition.getPropagationBehavior() == Propagation.MANDATORY) {
        if (isExistingTransaction(transaction)) {
            // 기존 트랜잭션이 있으면 참여
            return new DefaultTransactionStatus(transaction, false, false, false, true, null);
        } else {
            // 기존 트랜잭션이 없으면 예외 발생
            throw new IllegalTransactionStateException(
                "No existing transaction found for MANDATORY propagation");
        }
    }
}
```

### 5.4 사용 예제
```java
@Service
@Transactional(propagation = Propagation.MANDATORY)
public class AuditService {
    
    public void logBusinessProcess(String processName, Object data) {
        // 반드시 트랜잭션 컨텍스트에서 실행되어야 함
        // 트랜잭션 없이 호출되면 예외 발생
        AuditLog auditLog = new AuditLog(processName, data);
        auditRepository.save(auditLog);
    }
}

@Service
@Transactional
public class OrderService {
    
    @Autowired
    private AuditService auditService;
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 처리
            saveOrder(order);
            
            // 2. 감사 로그 (트랜잭션 컨텍스트에서 실행)
            auditService.logBusinessProcess("ORDER_PROCESSED", order);
            
        } catch (Exception e) {
            // 3. 감사 로그 (트랜잭션 컨텍스트에서 실행)
            auditService.logBusinessProcess("ORDER_FAILED", order);
            throw e;
        }
    }
}
```

## 6. NEVER

### 6.1 동작 원리
- **트랜잭션 없이 실행**
- 기존 트랜잭션이 있으면 예외 발생
- 트랜잭션과 함께 실행되면 안 되는 작업에 사용

### 6.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 1. OrderService.processOrder() - 트랜잭션 시작
            saveOrder(order);
            
            // 2. LogService.logOrder() - IllegalTransactionStateException 발생!
            logService.logOrder(order);
            
        } catch (Exception e) {
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.NEVER)
public class LogService {
    
    public void logOrder(Order order) {
        // 트랜잭션 없이 실행되어야 함
        // 트랜잭션과 함께 호출되면 예외 발생
        LogEntry logEntry = new LogEntry("Order processed", order.getId());
        logRepository.save(logEntry);
    }
}
```

### 6.3 내부 동작 과정
```java
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    if (definition.getPropagationBehavior() == Propagation.NEVER) {
        if (isExistingTransaction(transaction)) {
            // 기존 트랜잭션이 있으면 예외 발생
            throw new IllegalTransactionStateException(
                "Existing transaction found for NEVER propagation");
        } else {
            // 트랜잭션 없이 실행
            return new DefaultTransactionStatus(null, false, false, false, false, null);
        }
    }
}
```

### 6.4 사용 예제
```java
@Service
@Transactional(propagation = Propagation.NEVER)
public class LogService {
    
    public void logError(String message, Exception e) {
        // 트랜잭션 없이 실행되어야 함
        // 트랜잭션과 함께 호출되면 예외 발생
        LogEntry logEntry = new LogEntry("ERROR", message, e.getMessage());
        logRepository.save(logEntry);
    }
}

@Service
public class ErrorHandler {
    
    @Autowired
    private LogService logService;
    
    public void handleError(String message, Exception e) {
        // 트랜잭션 없이 호출 - 정상 동작
        logService.logError(message, e);
    }
}

// 잘못된 사용 예제
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            saveOrder(order);
        } catch (Exception e) {
            // IllegalTransactionStateException 발생!
            logService.logError("Order processing failed", e);
            throw e;
        }
    }
}
```

## 7. NESTED

### 7.1 동작 원리
- **중첩 트랜잭션 생성** (저장점 사용)
- 기존 트랜잭션이 있으면 중첩 트랜잭션 생성
- 없으면 새로운 트랜잭션 생성
- 부분 롤백이 가능한 트랜잭션

### 7.2 동작 시나리오
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private PaymentService paymentService;
    
    public void processOrder(Order order) {
        try {
            // 1. OrderService.processOrder() - 트랜잭션 시작
            saveOrder(order);
            
            // 2. PaymentService.processPayment() - 중첩 트랜잭션 시작
            paymentService.processPayment(order);
            
            // 3. 중첩 트랜잭션 커밋, 메인 트랜잭션 계속
            updateOrderStatus(order);
            
        } catch (PaymentException e) {
            // 4. 중첩 트랜잭션만 롤백, 메인 트랜잭션은 계속
            log.error("Payment failed", e);
            // 메인 트랜잭션은 계속 진행
        }
    }
}

@Service
@Transactional(propagation = Propagation.NESTED)
public class PaymentService {
    
    public void processPayment(Order order) {
        // 중첩 트랜잭션에서 실행
        // 실패해도 메인 트랜잭션에 영향을 주지 않음
        Payment payment = new Payment(order.getId(), order.getAmount());
        paymentRepository.save(payment);
        
        // 결제 처리 로직
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new PaymentException("Invalid payment amount");
        }
    }
}
```

### 7.3 내부 동작 과정
```java
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction) {
    if (definition.getPropagationBehavior() == Propagation.NESTED) {
        if (isExistingTransaction(transaction)) {
            // 중첩 트랜잭션 생성
            return createNestedTransaction(definition, transaction);
        } else {
            // 새로운 트랜잭션 생성
            return startNewTransaction(definition, transaction);
        }
    }
}

private TransactionStatus createNestedTransaction(TransactionDefinition definition, Object transaction) {
    // 1. 저장점 생성
    Object savepoint = createSavepoint(transaction);
    
    // 2. 중첩 트랜잭션 상태 생성
    return new DefaultTransactionStatus(transaction, false, false, false, true, savepoint);
}

// 롤백 처리
public void rollback(TransactionStatus status) {
    if (status.hasSavepoint()) {
        // 중첩 트랜잭션 롤백 - 저장점으로 롤백
        rollbackToSavepoint(status.getSavepoint());
    } else if (status.isNewTransaction()) {
        // 새로운 트랜잭션 롤백
        doRollback(status);
    } else {
        // 기존 트랜잭션에 롤백 마킹
        status.setRollbackOnly();
    }
}
```

### 7.4 사용 예제
```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private NotificationService notificationService;
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 저장 (메인 트랜잭션)
            saveOrder(order);
            
            // 2. 재고 차감 (중첩 트랜잭션)
            inventoryService.updateInventory(order);
            
            // 3. 결제 처리 (중첩 트랜잭션)
            paymentService.processPayment(order);
            
            // 4. 알림 발송 (중첩 트랜잭션)
            notificationService.sendOrderConfirmation(order);
            
        } catch (InventoryException e) {
            // 재고 부족 - 중첩 트랜잭션만 롤백
            log.error("Insufficient inventory", e);
            // 메인 트랜잭션은 계속 진행 (주문은 저장됨)
            
        } catch (PaymentException e) {
            // 결제 실패 - 중첩 트랜잭션만 롤백
            log.error("Payment failed", e);
            // 메인 트랜잭션은 계속 진행 (주문은 저장됨)
            
        } catch (Exception e) {
            // 기타 예외 - 전체 롤백
            log.error("Order processing failed", e);
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.NESTED)
public class InventoryService {
    
    public void updateInventory(Order order) {
        // 중첩 트랜잭션에서 실행
        for (OrderItem item : order.getItems()) {
            Product product = productRepository.findById(item.getProductId());
            if (product.getStock() < item.getQuantity()) {
                throw new InventoryException("Insufficient stock for product: " + product.getName());
            }
            product.setStock(product.getStock() - item.getQuantity());
            productRepository.save(product);
        }
    }
}
```

## 8. 전파 옵션 비교표

| 전파 옵션 | 기존 트랜잭션 있음 | 기존 트랜잭션 없음 | 사용 사례 |
|-----------|-------------------|-------------------|-----------|
| REQUIRED | 참여 | 새로 생성 | 일반적인 비즈니스 로직 |
| REQUIRES_NEW | 일시 중단 후 새로 생성 | 새로 생성 | 독립적인 작업 (로깅, 알림) |
| SUPPORTS | 참여 | 트랜잭션 없이 실행 | 선택적 트랜잭션 (읽기 작업) |
| NOT_SUPPORTED | 일시 중단 후 트랜잭션 없이 실행 | 트랜잭션 없이 실행 | 트랜잭션과 무관한 작업 |
| MANDATORY | 참여 | 예외 발생 | 트랜잭션 필수 작업 |
| NEVER | 예외 발생 | 트랜잭션 없이 실행 | 트랜잭션 금지 작업 |
| NESTED | 중첩 트랜잭션 생성 | 새로 생성 | 부분 롤백 가능한 작업 |

## 9. 실제 사용 시나리오

### 9.1 복잡한 비즈니스 로직
```java
@Service
@Transactional
public class ComplexBusinessService {
    
    @Autowired
    private DataService dataService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AuditService auditService;
    
    @Autowired
    private LogService logService;
    
    public void complexBusinessProcess(BusinessData data) {
        try {
            // 1. 데이터 검증 (REQUIRED)
            dataService.validateData(data);
            
            // 2. 비즈니스 로직 실행 (REQUIRED)
            processBusinessLogic(data);
            
            // 3. 알림 발송 (REQUIRES_NEW)
            notificationService.sendNotification(data);
            
            // 4. 감사 로그 (REQUIRES_NEW)
            auditService.logBusinessProcess(data);
            
        } catch (ValidationException e) {
            // 5. 검증 실패 로그 (NEVER)
            logService.logError("Validation failed", e);
            throw e;
            
        } catch (Exception e) {
            // 6. 기타 오류 로그 (NEVER)
            logService.logError("Business process failed", e);
            throw e;
        }
    }
}
```

### 9.2 성능 최적화를 위한 전파 전략
```java
@Service
@Transactional
public class OptimizedOrderService {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private EmailService emailService;
    
    public void processOrder(Order order) {
        // 1. 필수 검증 (REQUIRED)
        userService.validateUser(order.getUserId());
        productService.validateProducts(order.getItems());
        
        // 2. 주문 처리 (REQUIRED)
        saveOrder(order);
        updateInventory(order);
        
        // 3. 결제 처리 (REQUIRED)
        paymentService.processPayment(order);
        
        // 4. 이메일 발송 (REQUIRES_NEW) - 성능상 독립 실행
        try {
            emailService.sendOrderConfirmation(order);
        } catch (Exception e) {
            // 이메일 실패해도 주문은 완료
            log.warn("Email sending failed", e);
        }
    }
}
```

이제 다음 학습 자료에서 트랜잭션 격리 수준에 대해 알아보겠습니다.
