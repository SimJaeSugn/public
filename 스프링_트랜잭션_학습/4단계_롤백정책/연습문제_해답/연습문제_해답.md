# 4단계 연습문제 해답: 롤백 정책과 예외 처리

## 문제 1: 롤백 정책 기본 이해 (15점)

### 문제
다음 중 트랜잭션 롤백 정책에 대한 설명으로 **틀린** 것은?

### 답안
```
답: 4번

설명:
- 예외를 잡아서 처리하면 rollbackFor 설정과 관계없이 롤백되지 않습니다.
- 롤백이 발생하려면 예외를 다시 던져야 합니다.
- rollbackFor는 예외를 다시 던질 때만 적용됩니다.
- 예외를 잡아서 처리하면 트랜잭션은 정상 종료로 간주되어 커밋됩니다.
```

---

## 문제 2: 예외 처리 패턴 분석 (20점)

### 답안
```
패턴 1 (PaymentException을 잡아서 처리):
- 롤백 여부: 롤백되지 않음
- 이유: 예외를 잡아서 처리하면 rollbackFor 설정과 관계없이 롤백되지 않음

패턴 2 (DataAccessException을 다시 던지기):
- 롤백 여부: 롤백됨
- 이유: DataAccessException은 언체크 예외이므로 기본적으로 롤백됨

패턴 3 (BusinessException을 SystemException으로 변환):
- 롤백 여부: 롤백됨
- 이유: SystemException은 rollbackFor에 지정되어 있고, 예외를 다시 던지므로 롤백됨

패턴 4 (Exception을 잡아서 처리):
- 롤백 여부: 롤백되지 않음
- 이유: 예외를 잡아서 처리하면 rollbackFor 설정과 관계없이 롤백되지 않음
```

---

## 문제 3: 롤백 정책 설정 (25점)

### 답안
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class}, noRollbackFor = {ValidationException.class})
public class OrderService {
    
    public void processOrder(Order order) {
        try {
            // 주문 처리 로직
            processOrderLogic(order);
            
        } catch (ValidationException e) {
            // 검증 예외 처리
            handleValidationException(e);
            // 롤백되지 않음 (noRollbackFor에 지정)
            
        } catch (BusinessException e) {
            // 비즈니스 예외 처리
            handleBusinessException(e);
            throw e; // 롤백됨 (rollbackFor에 지정)
            
        } catch (SystemException e) {
            // 시스템 예외 처리
            handleSystemException(e);
            throw e; // 롤백됨 (rollbackFor에 지정)
            
        } catch (DataAccessException e) {
            // 데이터 접근 예외 처리
            handleDataAccessException(e);
            throw e; // 롤백됨 (언체크 예외이므로 기본적으로 롤백)
        }
    }
}
```

**설명:**
- `rollbackFor = {BusinessException.class, SystemException.class}`: 지정된 예외 발생 시 롤백
- `noRollbackFor = {ValidationException.class}`: 지정된 예외 발생 시 롤백하지 않음
- `DataAccessException`은 언체크 예외이므로 기본적으로 롤백됨

---

## 문제 4: 예외 처리 계층별 전략 (25점)

### 답안
```java
// 1. 서비스 계층
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        try {
            // 사용자 생성 로직
            validateUser(user);
            return userRepository.save(user);
            
        } catch (ValidationException e) {
            // 검증 예외는 비즈니스 예외로 변환
            throw new BusinessException("User validation failed: " + e.getMessage(), e);
        } catch (DataAccessException e) {
            // 데이터 접근 예외는 시스템 예외로 변환
            throw new SystemException("Database error", e);
        } catch (Exception e) {
            // 기타 예외는 시스템 예외로 변환
            throw new SystemException("Unexpected error", e);
        }
    }
    
    public User findUserById(Long id) {
        try {
            // 사용자 조회 로직
            User user = userRepository.findById(id);
            if (user == null) {
                throw new BusinessException("User not found with id: " + id);
            }
            return user;
            
        } catch (DataAccessException e) {
            // 데이터 접근 예외는 시스템 예외로 변환
            throw new SystemException("Database error", e);
        } catch (Exception e) {
            // 기타 예외는 시스템 예외로 변환
            throw new SystemException("Unexpected error", e);
        }
    }
    
    private void validateUser(User user) {
        if (user.getName() == null || user.getName().trim().isEmpty()) {
            throw new ValidationException("User name cannot be empty");
        }
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new ValidationException("Invalid email format");
        }
    }
}

// 2. 컨트롤러 계층
@RestController
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        try {
            User createdUser = userService.createUser(user);
            return ResponseEntity.ok(createdUser);
            
        } catch (BusinessException e) {
            // 비즈니스 예외 처리 (400 Bad Request)
            return ResponseEntity.badRequest().body(null);
            
        } catch (SystemException e) {
            // 시스템 예외 처리 (500 Internal Server Error)
            log.error("System error occurred", e);
            return ResponseEntity.status(500).body(null);
            
        } catch (Exception e) {
            // 기타 예외 처리 (500 Internal Server Error)
            log.error("Unexpected error occurred", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        try {
            User user = userService.findUserById(id);
            return ResponseEntity.ok(user);
            
        } catch (BusinessException e) {
            // 비즈니스 예외 처리 (404 Not Found)
            return ResponseEntity.notFound().build();
            
        } catch (SystemException e) {
            // 시스템 예외 처리 (500 Internal Server Error)
            log.error("System error occurred", e);
            return ResponseEntity.status(500).body(null);
            
        } catch (Exception e) {
            // 기타 예외 처리 (500 Internal Server Error)
            log.error("Unexpected error occurred", e);
            return ResponseEntity.status(500).body(null);
        }
    }
}
```

**설명:**
- **서비스 계층**: 비즈니스 예외와 시스템 예외로 구분하여 처리
- **컨트롤러 계층**: HTTP 응답 코드별로 예외 처리
- **롤백 정책**: BusinessException과 SystemException 발생 시 롤백
- **예외 변환**: 하위 계층의 예외를 상위 계층에 맞는 예외로 변환

---

## 문제 5: 복잡한 예외 처리 시나리오 (15점)

### 답안
```
발견된 문제점:

1. PaymentException을 잡아서 처리
   문제: 예외를 잡아서 처리하면 롤백되지 않음
   영향: 결제 실패해도 주문이 저장됨 (데이터 일관성 깨짐)

2. NotificationException을 잡아서 처리
   문제: 예외를 잡아서 처리하면 롤백되지 않음
   영향: 알림 실패해도 주문이 저장됨 (데이터 일관성 깨짐)

3. 롤백 정책과 예외 처리 불일치
   문제: rollbackFor = Exception.class로 설정했지만 예외를 잡아서 처리
   영향: 롤백 정책이 제대로 작동하지 않음

해결방안:

1. 예외를 다시 던지기
   방법: 예외를 잡아서 로깅한 후 다시 던지기
   효과: 롤백 정책이 제대로 작동하여 데이터 일관성 보장

2. 롤백 정책 명시적 설정
   방법: 필요한 예외만 롤백하도록 설정
   효과: 명확한 롤백 정책으로 예측 가능한 동작

3. 예외 처리 계층별 분리
   방법: 서비스 계층에서 예외 변환, 컨트롤러 계층에서 HTTP 응답
   효과: 각 계층의 책임이 명확해짐

수정된 코드:
```

```java
@Service
@Transactional(rollbackFor = {PaymentException.class, SystemException.class})
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private NotificationService notificationService;
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 저장
            orderRepository.save(order);
            
            // 2. 결제 처리
            paymentService.processPayment(order);
            
            // 3. 알림 발송 (트랜잭션 외부에서 실행)
            sendNotificationAsync(order);
            
        } catch (PaymentException e) {
            // 결제 실패 시 로깅 후 예외를 다시 던져서 롤백
            log.error("Payment failed for order: {}", order.getId(), e);
            throw e; // 롤백됨
            
        } catch (NotificationException e) {
            // 알림 실패는 롤백하지 않음 (트랜잭션 외부에서 실행)
            log.error("Notification failed for order: {}", order.getId(), e);
            // 롤백되지 않음
            
        } catch (Exception e) {
            // 기타 예외는 시스템 예외로 변환하여 롤백
            log.error("Unexpected error for order: {}", order.getId(), e);
            throw new SystemException("Unexpected error", e);
        }
    }
    
    @Async
    private void sendNotificationAsync(Order order) {
        try {
            notificationService.sendNotification(order);
        } catch (NotificationException e) {
            log.error("Notification failed for order: {}", order.getId(), e);
        }
    }
}
```

**추가 해결방안:**
```java
// 대안 1: 트랜잭션 분리
@Service
@Transactional(rollbackFor = {PaymentException.class})
public class OrderService {
    
    public void processOrder(Order order) {
        // 1. 주문 저장 (트랜잭션 1)
        saveOrder(order);
        
        // 2. 결제 처리 (트랜잭션 2)
        processPayment(order);
        
        // 3. 알림 발송 (트랜잭션 없이)
        sendNotification(order);
    }
    
    @Transactional
    public void saveOrder(Order order) {
        orderRepository.save(order);
    }
    
    @Transactional(rollbackFor = PaymentException.class)
    public void processPayment(Order order) {
        paymentService.processPayment(order);
    }
    
    public void sendNotification(Order order) {
        try {
            notificationService.sendNotification(order);
        } catch (NotificationException e) {
            log.error("Notification failed", e);
        }
    }
}
```

---

## 추가 학습 포인트

### 1. 롤백 정책 선택 기준
- **기본 정책**: 언체크 예외는 롤백, 체크 예외는 커밋
- **rollbackFor**: 특정 예외 발생 시 롤백
- **noRollbackFor**: 특정 예외 발생 시 롤백하지 않음

### 2. 예외 처리 패턴
- **예외를 잡아서 처리**: 롤백되지 않음
- **예외를 다시 던지기**: 롤백됨
- **예외 변환**: 변환된 예외의 타입에 따라 롤백 결정

### 3. 실무 적용 시 주의사항
- 롤백 정책을 명시적으로 설정
- 예외 처리 계층별 분리
- 로깅과 롤백의 관계 고려
- 트랜잭션 범위 최소화
