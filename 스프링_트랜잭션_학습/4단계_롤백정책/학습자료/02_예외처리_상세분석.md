# 예외 처리와 롤백 정책 상세 분석

## 1. 예외 타입별 롤백 처리 메커니즘

### 1.1 언체크 예외 (Unchecked Exception)
```java
// RuntimeException과 그 하위 클래스들
@Transactional
public void uncheckedExceptionExample() {
    // 1. RuntimeException - 기본적으로 롤백
    throw new RuntimeException("This will cause rollback");
    
    // 2. IllegalArgumentException - 기본적으로 롤백
    throw new IllegalArgumentException("This will cause rollback");
    
    // 3. NullPointerException - 기본적으로 롤백
    throw new NullPointerException("This will cause rollback");
    
    // 4. Error - 기본적으로 롤백
    throw new Error("This will cause rollback");
}
```

### 1.2 체크 예외 (Checked Exception)
```java
// Exception과 그 하위 클래스들 (RuntimeException 제외)
@Transactional
public void checkedExceptionExample() throws Exception {
    // 1. Exception - 기본적으로 커밋
    throw new Exception("This will NOT cause rollback");
    
    // 2. SQLException - 기본적으로 커밋
    throw new SQLException("This will NOT cause rollback");
    
    // 3. IOException - 기본적으로 커밋
    throw new IOException("This will NOT cause rollback");
}
```

### 1.3 예외 상속 관계와 롤백 처리
```java
// 예외 상속 관계
public class CustomException extends Exception {
    // 체크 예외 - 기본적으로 커밋
}

public class CustomRuntimeException extends RuntimeException {
    // 언체크 예외 - 기본적으로 롤백
}

// 롤백 처리
@Transactional
public void exceptionInheritanceExample() throws CustomException {
    // CustomException은 Exception의 하위 클래스이므로 커밋
    throw new CustomException("This will NOT cause rollback");
    
    // CustomRuntimeException은 RuntimeException의 하위 클래스이므로 롤백
    throw new CustomRuntimeException("This will cause rollback");
}
```

## 2. rollbackFor 속성 상세 분석

### 2.1 단일 예외 클래스 지정
```java
@Transactional(rollbackFor = SQLException.class)
public void singleExceptionRollback() throws SQLException {
    // SQLException 발생 시 롤백
    throw new SQLException("Database error");
}

@Transactional(rollbackFor = BusinessException.class)
public void businessExceptionRollback() {
    // BusinessException 발생 시 롤백
    throw new BusinessException("Business error");
}
```

### 2.2 여러 예외 클래스 지정
```java
@Transactional(rollbackFor = {SQLException.class, DataAccessException.class, BusinessException.class})
public void multipleExceptionRollback() throws SQLException {
    // 지정된 예외들 중 하나라도 발생하면 롤백
    if (someCondition) {
        throw new SQLException("Database error");
    } else if (anotherCondition) {
        throw new DataAccessException("Data access error");
    } else {
        throw new BusinessException("Business error");
    }
}
```

### 2.3 모든 예외 롤백
```java
@Transactional(rollbackFor = Exception.class)
public void allExceptionRollback() throws Exception {
    // 모든 예외 발생 시 롤백
    throw new Exception("Any exception will cause rollback");
}

@Transactional(rollbackFor = Throwable.class)
public void allThrowableRollback() throws Throwable {
    // 모든 Throwable 발생 시 롤백 (Exception과 Error 포함)
    throw new Throwable("Any throwable will cause rollback");
}
```

### 2.4 예외 상속 관계 고려
```java
// 부모 예외를 지정하면 하위 예외도 포함
@Transactional(rollbackFor = Exception.class)
public void parentExceptionRollback() throws SQLException {
    // SQLException은 Exception의 하위 클래스이므로 롤백됨
    throw new SQLException("This will cause rollback");
}

// 구체적인 예외만 지정
@Transactional(rollbackFor = {SQLException.class, IOException.class})
public void specificExceptionRollback() throws Exception {
    // SQLException과 IOException만 롤백
    // 다른 Exception은 커밋됨
    throw new Exception("This will NOT cause rollback");
}
```

## 3. noRollbackFor 속성 상세 분석

### 3.1 단일 예외 클래스 지정
```java
@Transactional(noRollbackFor = IllegalArgumentException.class)
public void singleExceptionNoRollback() {
    // IllegalArgumentException 발생 시 롤백하지 않음
    throw new IllegalArgumentException("This will NOT cause rollback");
}

@Transactional(noRollbackFor = ValidationException.class)
public void validationExceptionNoRollback() {
    // ValidationException 발생 시 롤백하지 않음
    throw new ValidationException("This will NOT cause rollback");
}
```

### 3.2 여러 예외 클래스 지정
```java
@Transactional(noRollbackFor = {IllegalArgumentException.class, ValidationException.class})
public void multipleExceptionNoRollback() {
    // 지정된 예외들 중 하나라도 발생하면 롤백하지 않음
    if (someCondition) {
        throw new IllegalArgumentException("This will NOT cause rollback");
    } else {
        throw new ValidationException("This will NOT cause rollback");
    }
}
```

### 3.3 언체크 예외도 롤백하지 않음
```java
@Transactional(noRollbackFor = RuntimeException.class)
public void uncheckedExceptionNoRollback() {
    // RuntimeException 발생 시 롤백하지 않음
    throw new RuntimeException("This will NOT cause rollback");
}

@Transactional(noRollbackFor = {RuntimeException.class, Error.class})
public void allUncheckedExceptionNoRollback() {
    // RuntimeException과 Error 발생 시 롤백하지 않음
    throw new RuntimeException("This will NOT cause rollback");
}
```

## 4. 예외 처리 패턴별 롤백 동작

### 4.1 예외를 잡아서 처리하는 경우
```java
@Transactional
public void catchAndHandleException() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (Exception e) {
        // 예외를 잡아서 처리하면 롤백되지 않음
        log.error("Error occurred", e);
        // 트랜잭션은 커밋됨
    }
}

@Transactional(rollbackFor = Exception.class)
public void catchAndHandleWithRollbackFor() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (Exception e) {
        // rollbackFor가 설정되어 있어도 예외를 잡아서 처리하면 롤백되지 않음
        log.error("Error occurred", e);
        // 트랜잭션은 커밋됨
    }
}
```

### 4.2 예외를 다시 던지는 경우
```java
@Transactional
public void rethrowException() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (Exception e) {
        // 예외를 다시 던지면 롤백됨
        log.error("Error occurred", e);
        throw e; // 롤백됨
    }
}

@Transactional(rollbackFor = Exception.class)
public void rethrowWithRollbackFor() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (Exception e) {
        // rollbackFor가 설정되어 있고 예외를 다시 던지면 롤백됨
        log.error("Error occurred", e);
        throw e; // 롤백됨
    }
}
```

### 4.3 예외 변환과 롤백 처리
```java
@Transactional
public void convertException() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (SQLException e) {
        // 체크 예외를 언체크 예외로 변환
        throw new RuntimeException("Database error", e);
    }
}

@Transactional(rollbackFor = Exception.class)
public void convertToCheckedException() throws Exception {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (RuntimeException e) {
        // 언체크 예외를 체크 예외로 변환
        throw new Exception("Business error", e);
    }
}
```

## 5. 실제 사용 시나리오

### 5.1 비즈니스 예외 처리
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    public void processOrder(Order order) {
        try {
            // 주문 저장
            orderRepository.save(order);
            
            // 결제 처리
            paymentService.processPayment(order);
            
        } catch (PaymentException e) {
            // PaymentException은 체크 예외이지만 롤백됨
            log.error("Payment failed for order: {}", order.getId(), e);
            throw new BusinessException("Payment processing failed", e);
        } catch (DataAccessException e) {
            // DataAccessException은 언체크 예외이므로 롤백됨
            log.error("Database error for order: {}", order.getId(), e);
            throw new SystemException("Database error", e);
        }
    }
}
```

### 5.2 예외 처리 계층별 전략
```java
// 서비스 계층: 비즈니스 예외 처리
@Service
@Transactional(rollbackFor = Exception.class)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        try {
            // 사용자 저장
            return userRepository.save(user);
            
        } catch (DataAccessException e) {
            // 데이터베이스 예외를 비즈니스 예외로 변환
            throw new UserCreationException("Failed to create user", e);
        } catch (Exception e) {
            // 기타 예외를 시스템 예외로 변환
            throw new SystemException("Unexpected error", e);
        }
    }
}

// 컨트롤러 계층: HTTP 응답 처리
@RestController
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        try {
            User createdUser = userService.createUser(user);
            return ResponseEntity.ok(createdUser);
            
        } catch (UserCreationException e) {
            // 비즈니스 예외 처리
            return ResponseEntity.badRequest().body(null);
            
        } catch (SystemException e) {
            // 시스템 예외 처리
            return ResponseEntity.status(500).body(null);
            
        } catch (Exception e) {
            // 기타 예외 처리
            return ResponseEntity.status(500).body(null);
        }
    }
}
```

### 5.3 복잡한 예외 처리 시나리오
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class ComplexBusinessService {
    
    @Autowired
    private DataService dataService;
    
    @Autowired
    private NotificationService notificationService;
    
    public void complexBusinessProcess(BusinessData data) {
        try {
            // 1. 데이터 검증
            dataService.validateData(data);
            
            // 2. 비즈니스 로직 실행
            processBusinessLogic(data);
            
            // 3. 알림 발송
            notificationService.sendNotification(data);
            
        } catch (ValidationException e) {
            // 검증 예외는 비즈니스 예외로 변환
            log.error("Validation failed", e);
            throw new BusinessException("Data validation failed", e);
            
        } catch (NotificationException e) {
            // 알림 예외는 시스템 예외로 변환
            log.error("Notification failed", e);
            throw new SystemException("Notification failed", e);
            
        } catch (Exception e) {
            // 기타 예외는 시스템 예외로 변환
            log.error("Unexpected error", e);
            throw new SystemException("Unexpected error", e);
        }
    }
}
```

## 6. 롤백 정책과 예외 처리의 관계

### 6.1 롤백 결정 과정
```java
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public void rollbackDecisionProcess() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (BusinessException e) {
        // BusinessException은 rollbackFor에 지정되어 있으므로 롤백
        log.error("Business error", e);
        throw e;
        
    } catch (SystemException e) {
        // SystemException은 rollbackFor에 지정되어 있으므로 롤백
        log.error("System error", e);
        throw e;
        
    } catch (ValidationException e) {
        // ValidationException은 언체크 예외이므로 롤백
        log.error("Validation error", e);
        throw e;
        
    } catch (Exception e) {
        // 기타 예외는 롤백되지 않음
        log.error("Other error", e);
        throw e;
    }
}
```

### 6.2 예외 처리 순서
```java
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public void exceptionHandlingOrder() {
    try {
        // 1. 비즈니스 로직 실행
        processBusinessLogic();
        
    } catch (SpecificBusinessException e) {
        // 2. 구체적인 비즈니스 예외 처리
        handleSpecificBusinessException(e);
        throw e; // 롤백됨
        
    } catch (BusinessException e) {
        // 3. 일반적인 비즈니스 예외 처리
        handleBusinessException(e);
        throw e; // 롤백됨
        
    } catch (SystemException e) {
        // 4. 시스템 예외 처리
        handleSystemException(e);
        throw e; // 롤백됨
        
    } catch (Exception e) {
        // 5. 모든 예외 처리
        handleAllExceptions(e);
        throw e; // 롤백되지 않음
    }
}
```

## 7. 주의사항 및 베스트 프랙티스

### 7.1 예외를 잡아서 처리할 때 주의사항
```java
// 잘못된 예: 예외를 잡아서 처리하면 롤백되지 않음
@Transactional(rollbackFor = Exception.class)
public void wrongExceptionHandling() {
    try {
        processBusinessLogic();
    } catch (Exception e) {
        // 예외를 잡아서 처리하면 롤백되지 않음
        log.error("Error occurred", e);
        // 트랜잭션은 커밋됨
    }
}

// 올바른 예: 예외를 다시 던져야 롤백됨
@Transactional(rollbackFor = Exception.class)
public void correctExceptionHandling() {
    try {
        processBusinessLogic();
    } catch (Exception e) {
        log.error("Error occurred", e);
        // 예외를 다시 던져야 롤백됨
        throw e;
    }
}
```

### 7.2 롤백 정책 명시적 설정
```java
// 명시적 롤백 정책 설정
@Transactional(
    rollbackFor = {BusinessException.class, SystemException.class},
    noRollbackFor = {ValidationException.class}
)
public void explicitRollbackPolicy() {
    // 롤백 정책이 명확하게 정의됨
    processBusinessLogic();
}
```

### 7.3 예외 처리 계층별 분리
```java
// 서비스 계층: 비즈니스 예외 처리
@Service
@Transactional(rollbackFor = Exception.class)
public class BusinessService {
    
    public void processBusinessLogic() {
        try {
            // 비즈니스 로직
        } catch (Exception e) {
            // 비즈니스 예외로 변환
            throw new BusinessException("Business error", e);
        }
    }
}

// 컨트롤러 계층: HTTP 응답 처리
@RestController
public class BusinessController {
    
    @PostMapping("/process")
    public ResponseEntity<String> process() {
        try {
            businessService.processBusinessLogic();
            return ResponseEntity.ok("Success");
        } catch (BusinessException e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Internal error");
        }
    }
}
```

## 8. 실무 예외 처리 전략

### 8.1 비즈니스 예외와 시스템 예외 구분
```java
// 비즈니스 예외 (사용자 입력 오류 등)
public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }
    
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 시스템 예외 (데이터베이스 오류 등)
public class SystemException extends RuntimeException {
    public SystemException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 서비스에서 예외 구분
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class UserService {
    
    public User createUser(User user) {
        try {
            // 비즈니스 로직
            validateUser(user);
            return userRepository.save(user);
            
        } catch (ValidationException e) {
            // 비즈니스 예외로 변환
            throw new BusinessException("User validation failed: " + e.getMessage());
        } catch (DataAccessException e) {
            // 시스템 예외로 변환
            throw new SystemException("Database error", e);
        }
    }
}
```

### 8.2 로깅과 롤백의 관계
```java
@Service
@Transactional
public class OrderService {
    
    public void processOrder(Order order) {
        try {
            // 주문 처리
            processOrderLogic(order);
            
        } catch (Exception e) {
            // 로깅 후 예외를 다시 던져서 롤백
            log.error("Order processing failed for order: {}", order.getId(), e);
            throw e;
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void processOrderWithLogging(Order order) {
        try {
            // 주문 처리
            processOrderLogic(order);
            
        } catch (Exception e) {
            // 로깅은 롤백과 무관하게 실행
            log.error("Order processing failed for order: {}", order.getId(), e);
            throw e;
        }
    }
}
```

이제 다음 학습 자료에서 실제 코드 예제와 실습에 대해 알아보겠습니다.
