# 트랜잭션 롤백 정책과 예외 처리 기본 개념

## 1. 롤백 정책이란?

### 정의
롤백 정책(Rollback Policy)은 **트랜잭션 실행 중 예외가 발생했을 때 트랜잭션을 롤백할지 커밋할지를 결정하는 규칙**입니다.

### 왜 필요한가?
```java
// 롤백 정책이 없다면 발생할 수 있는 문제
@Service
@Transactional
public class OrderService {
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 저장
            orderRepository.save(order);
            
            // 2. 재고 차감
            updateInventory(order);
            
            // 3. 결제 처리
            processPayment(order);
            
        } catch (Exception e) {
            // 예외가 발생해도 트랜잭션이 커밋됨
            // 주문은 저장되었지만 재고는 차감되지 않음
            // 데이터 일관성 깨짐!
        }
    }
}
```

## 2. 롤백과 커밋의 차이점

### 2.1 커밋 (Commit)
```java
@Transactional
public void successfulTransaction() {
    // 1. 데이터 수정
    userRepository.save(new User("John"));
    accountRepository.save(new Account(1000));
    
    // 2. 정상 종료 시 자동 커밋
    // 모든 변경사항이 데이터베이스에 영구 저장됨
}
```

### 2.2 롤백 (Rollback)
```java
@Transactional
public void failedTransaction() {
    // 1. 데이터 수정
    userRepository.save(new User("John"));
    accountRepository.save(new Account(1000));
    
    // 2. 예외 발생
    throw new RuntimeException("Something went wrong");
    
    // 3. 자동 롤백
    // 모든 변경사항이 취소됨
}
```

## 3. 기본 롤백 정책

### 3.1 스프링의 기본 롤백 정책
```java
// 기본 롤백 정책
@Transactional
public void defaultRollbackPolicy() {
    // 언체크 예외 (RuntimeException, Error) 발생 시 롤백
    throw new RuntimeException("This will cause rollback");
    
    // 체크 예외 (Exception) 발생 시 커밋
    // throw new Exception("This will NOT cause rollback");
}
```

### 3.2 예외 타입별 롤백 처리
```java
// 언체크 예외 - 기본적으로 롤백
@Transactional
public void uncheckedException() {
    throw new RuntimeException("Unchecked exception - will rollback");
}

// 체크 예외 - 기본적으로 커밋
@Transactional
public void checkedException() throws Exception {
    throw new Exception("Checked exception - will NOT rollback");
}

// Error - 기본적으로 롤백
@Transactional
public void error() {
    throw new Error("Error - will rollback");
}
```

## 4. 롤백 정책 설정

### 4.1 rollbackFor 속성
```java
// 특정 예외 발생 시 롤백
@Transactional(rollbackFor = {SQLException.class, DataAccessException.class})
public void specificRollback() throws SQLException {
    // SQLException이나 DataAccessException 발생 시 롤백
    throw new SQLException("Database error");
}

// 모든 예외 발생 시 롤백
@Transactional(rollbackFor = Exception.class)
public void allExceptionsRollback() throws Exception {
    // 모든 예외 발생 시 롤백
    throw new Exception("Any exception will cause rollback");
}
```

### 4.2 noRollbackFor 속성
```java
// 특정 예외 발생 시 롤백하지 않음
@Transactional(noRollbackFor = {IllegalArgumentException.class})
public void specificNoRollback() {
    // IllegalArgumentException 발생 시 롤백하지 않음
    throw new IllegalArgumentException("This will NOT cause rollback");
}

// 언체크 예외도 롤백하지 않음
@Transactional(noRollbackFor = RuntimeException.class)
public void uncheckedNoRollback() {
    // RuntimeException 발생 시 롤백하지 않음
    throw new RuntimeException("This will NOT cause rollback");
}
```

## 5. 예외 처리 패턴

### 5.1 예외를 잡아서 처리하는 경우
```java
@Transactional
public void catchAndHandleException() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (Exception e) {
        // 예외를 잡아서 처리하면 롤백되지 않음
        log.error("Error occurred", e);
        // 트랜잭션은 커밋됨
    }
}
```

### 5.2 예외를 다시 던지는 경우
```java
@Transactional
public void rethrowException() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (Exception e) {
        // 예외를 다시 던지면 롤백됨
        log.error("Error occurred", e);
        throw e; // 또는 throw new RuntimeException(e);
    }
}
```

### 5.3 예외 변환과 롤백 처리
```java
@Transactional
public void convertException() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (SQLException e) {
        // 체크 예외를 언체크 예외로 변환
        throw new RuntimeException("Database error", e);
    }
}

@Transactional(rollbackFor = Exception.class)
public void convertToCheckedException() throws Exception {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (RuntimeException e) {
        // 언체크 예외를 체크 예외로 변환
        throw new Exception("Business error", e);
    }
}
```

## 6. 실제 사용 예제

### 6.1 기본 롤백 정책 사용
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        try {
            // 사용자 저장
            User savedUser = userRepository.save(user);
            
            // 추가 검증
            validateUser(savedUser);
            
            return savedUser;
            
        } catch (ValidationException e) {
            // ValidationException은 언체크 예외이므로 롤백됨
            log.error("User validation failed", e);
            throw e;
        }
    }
    
    private void validateUser(User user) {
        if (user.getName() == null || user.getName().trim().isEmpty()) {
            throw new ValidationException("User name cannot be empty");
        }
    }
}
```

### 6.2 커스텀 롤백 정책 사용
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    public void processOrder(Order order) {
        try {
            // 주문 저장
            orderRepository.save(order);
            
            // 결제 처리
            paymentService.processPayment(order);
            
        } catch (PaymentException e) {
            // PaymentException은 체크 예외이지만 롤백됨
            log.error("Payment failed", e);
            throw e;
        } catch (Exception e) {
            // 기타 예외는 롤백되지 않음
            log.error("Unexpected error", e);
            throw new SystemException("System error", e);
        }
    }
}
```

### 6.3 예외 처리 계층별 전략
```java
// 서비스 계층
@Service
@Transactional(rollbackFor = Exception.class)
public class UserService {
    
    public User createUser(User user) {
        try {
            return userRepository.save(user);
        } catch (DataAccessException e) {
            // 데이터베이스 예외를 비즈니스 예외로 변환
            throw new UserCreationException("Failed to create user", e);
        }
    }
}

// 컨트롤러 계층
@RestController
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        try {
            User createdUser = userService.createUser(user);
            return ResponseEntity.ok(createdUser);
        } catch (UserCreationException e) {
            // 비즈니스 예외 처리
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            // 시스템 예외 처리
            return ResponseEntity.status(500).build();
        }
    }
}
```

## 7. 롤백 정책과 예외 처리의 관계

### 7.1 예외 처리 순서
```java
@Transactional
public void exceptionHandlingOrder() {
    try {
        // 1. 비즈니스 로직 실행
        processBusinessLogic();
        
    } catch (SpecificException e) {
        // 2. 구체적인 예외 처리
        handleSpecificException(e);
        
    } catch (GeneralException e) {
        // 3. 일반적인 예외 처리
        handleGeneralException(e);
        
    } catch (Exception e) {
        // 4. 모든 예외 처리
        handleAllExceptions(e);
    }
}
```

### 7.2 롤백 결정 과정
```java
@Transactional(rollbackFor = {BusinessException.class})
public void rollbackDecisionProcess() {
    try {
        // 비즈니스 로직
        processBusinessLogic();
        
    } catch (BusinessException e) {
        // BusinessException은 rollbackFor에 지정되어 있으므로 롤백
        log.error("Business error", e);
        throw e;
        
    } catch (ValidationException e) {
        // ValidationException은 언체크 예외이므로 롤백
        log.error("Validation error", e);
        throw e;
        
    } catch (Exception e) {
        // 기타 예외는 롤백되지 않음
        log.error("Other error", e);
        throw e;
    }
}
```

## 8. 주의사항 및 베스트 프랙티스

### 8.1 예외를 잡아서 처리할 때 주의사항
```java
// 잘못된 예: 예외를 잡아서 처리하면 롤백되지 않음
@Transactional
public void wrongExceptionHandling() {
    try {
        processBusinessLogic();
    } catch (Exception e) {
        // 예외를 잡아서 처리하면 롤백되지 않음
        log.error("Error occurred", e);
        // 트랜잭션은 커밋됨
    }
}

// 올바른 예: 예외를 다시 던져야 롤백됨
@Transactional
public void correctExceptionHandling() {
    try {
        processBusinessLogic();
    } catch (Exception e) {
        log.error("Error occurred", e);
        // 예외를 다시 던져야 롤백됨
        throw e;
    }
}
```

### 8.2 롤백 정책 명시적 설정
```java
// 명시적 롤백 정책 설정
@Transactional(
    rollbackFor = {BusinessException.class, SystemException.class},
    noRollbackFor = {ValidationException.class}
)
public void explicitRollbackPolicy() {
    // 롤백 정책이 명확하게 정의됨
    processBusinessLogic();
}
```

### 8.3 예외 처리 계층별 분리
```java
// 서비스 계층: 비즈니스 예외 처리
@Service
@Transactional(rollbackFor = Exception.class)
public class BusinessService {
    
    public void processBusinessLogic() {
        try {
            // 비즈니스 로직
        } catch (Exception e) {
            // 비즈니스 예외로 변환
            throw new BusinessException("Business error", e);
        }
    }
}

// 컨트롤러 계층: HTTP 응답 처리
@RestController
public class BusinessController {
    
    @PostMapping("/process")
    public ResponseEntity<String> process() {
        try {
            businessService.processBusinessLogic();
            return ResponseEntity.ok("Success");
        } catch (BusinessException e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Internal error");
        }
    }
}
```

## 9. 실무 예외 처리 전략

### 9.1 비즈니스 예외와 시스템 예외 구분
```java
// 비즈니스 예외 (사용자 입력 오류 등)
public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }
}

// 시스템 예외 (데이터베이스 오류 등)
public class SystemException extends RuntimeException {
    public SystemException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 서비스에서 예외 구분
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class UserService {
    
    public User createUser(User user) {
        try {
            // 비즈니스 로직
            validateUser(user);
            return userRepository.save(user);
            
        } catch (ValidationException e) {
            // 비즈니스 예외로 변환
            throw new BusinessException("User validation failed: " + e.getMessage());
        } catch (DataAccessException e) {
            // 시스템 예외로 변환
            throw new SystemException("Database error", e);
        }
    }
}
```

### 9.2 로깅과 롤백의 관계
```java
@Service
@Transactional
public class OrderService {
    
    public void processOrder(Order order) {
        try {
            // 주문 처리
            processOrderLogic(order);
            
        } catch (Exception e) {
            // 로깅 후 예외를 다시 던져서 롤백
            log.error("Order processing failed for order: {}", order.getId(), e);
            throw e;
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void processOrderWithLogging(Order order) {
        try {
            // 주문 처리
            processOrderLogic(order);
            
        } catch (Exception e) {
            // 로깅은 롤백과 무관하게 실행
            log.error("Order processing failed for order: {}", order.getId(), e);
            throw e;
        }
    }
}
```

이제 다음 학습 자료에서 예외 처리와 롤백 정책의 상세한 동작 원리를 알아보겠습니다.
