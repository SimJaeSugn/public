# 5단계 연습문제 해답: 실제 코드 예제와 실습

## 문제 1: 트랜잭션 설계 분석 (20점)

### 답안
```
트랜잭션 설계 분석:

1. 현재 설계의 문제점:
   - 모든 서비스가 기본 @Transactional을 사용하여 불필요한 트랜잭션 생성
   - 이메일 발송과 로그 기록이 메인 트랜잭션에 포함되어 성능 저하
   - 예외 발생 시 모든 작업이 롤백되어 불필요한 롤백 발생
   - 트랜잭션 범위가 너무 넓어 락 유지 시간 증가

2. 개선방안:
   - 이메일 발송과 로그 기록을 별도 트랜잭션으로 분리
   - 적절한 전파 옵션 사용
   - 롤백 정책 명시적 설정
   - 트랜잭션 범위 최소화

3. 수정된 코드:
```

```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private LogService logService;
    
    public void processOrder(Order order) {
        try {
            // 1. 주문 저장
            orderRepository.save(order);
            
            // 2. 결제 처리 (같은 트랜잭션)
            paymentService.processPayment(order);
            
            // 3. 이메일 발송 (별도 트랜잭션)
            emailService.sendOrderConfirmationAsync(order);
            
            // 4. 로그 기록 (별도 트랜잭션)
            logService.logOrderProcessAsync(order);
            
        } catch (Exception e) {
            log.error("Order processing failed", e);
            throw e;
        }
    }
}

@Service
@Transactional(propagation = Propagation.REQUIRED)
public class PaymentService {
    
    public void processPayment(Order order) {
        // 결제 처리 로직
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class EmailService {
    
    @Async
    public void sendOrderConfirmationAsync(Order order) {
        try {
            sendOrderConfirmation(order);
        } catch (Exception e) {
            log.error("Failed to send order confirmation email", e);
        }
    }
    
    public void sendOrderConfirmation(Order order) {
        // 이메일 발송 로직
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class LogService {
    
    @Async
    public void logOrderProcessAsync(Order order) {
        try {
            logOrderProcess(order);
        } catch (Exception e) {
            log.error("Failed to log order process", e);
        }
    }
    
    public void logOrderProcess(Order order) {
        // 로그 기록 로직
    }
}
```

---

## 문제 2: 성능 최적화 (25점)

### 답안
```
성능 문제 분석:

1. 격리 수준 문제:
   - SERIALIZABLE은 가장 높은 격리 수준으로 성능 저하
   - 동시성이 최소화되어 처리량 감소
   - 락 사용량이 최대

2. 트랜잭션 범위 문제:
   - 외부 API 호출까지 트랜잭션 내에서 실행
   - 트랜잭션이 오래 유지되어 락 경합 증가
   - 메모리 사용량 증가

3. 외부 API 호출 문제:
   - 외부 API 호출이 트랜잭션 내에서 실행
   - 네트워크 지연으로 인한 트랜잭션 유지 시간 증가
   - 외부 API 실패 시 전체 롤백

최적화 방안:

1. 격리 수준 최적화:
   - READ_COMMITTED 또는 REPEATABLE_READ 사용
   - 필요한 경우에만 높은 격리 수준 사용

2. 트랜잭션 범위 최적화:
   - 외부 API 호출을 트랜잭션 외부로 분리
   - 트랜잭션을 필요한 작업만 포함하도록 최소화

3. 외부 API 호출 최적화:
   - 비동기 처리로 트랜잭션과 분리
   - 재시도 로직 추가

최적화된 코드:
```

```java
@Service
@Transactional(
    isolation = Isolation.READ_COMMITTED,
    rollbackFor = {BusinessException.class, SystemException.class}
)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public void updateUserProfile(Long userId, UserProfile profile) {
        try {
            // 1. 사용자 조회
            User user = userRepository.findById(userId).orElseThrow();
            
            // 2. 프로필 업데이트
            user.setName(profile.getName());
            user.setEmail(profile.getEmail());
            user.setPhone(profile.getPhone());
            
            // 3. 사용자 저장
            userRepository.save(user);
            
            // 4. 외부 API 호출 (트랜잭션 외부)
            callExternalAPIAsync(user);
            
            // 5. 이메일 발송 (트랜잭션 외부)
            emailService.sendProfileUpdateEmailAsync(user);
            
        } catch (Exception e) {
            log.error("User profile update failed", e);
            throw e;
        }
    }
    
    @Async
    private void callExternalAPIAsync(User user) {
        try {
            callExternalAPI(user);
        } catch (Exception e) {
            log.error("External API call failed", e);
        }
    }
    
    private void callExternalAPI(User user) {
        // 외부 API 호출 로직
    }
}

@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class EmailService {
    
    @Async
    public void sendProfileUpdateEmailAsync(User user) {
        try {
            sendProfileUpdateEmail(user);
        } catch (Exception e) {
            log.error("Failed to send profile update email", e);
        }
    }
    
    public void sendProfileUpdateEmail(User user) {
        // 이메일 발송 로직
    }
}
```

---

## 문제 3: 예외 처리 전략 (25점)

### 답안
```java
// 1. 사용자 서비스
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private AuditService auditService;
    
    public User registerUser(User user) {
        try {
            // 1. 이메일 중복 확인
            if (userRepository.findByEmail(user.getEmail()).isPresent()) {
                throw new BusinessException("Email already exists: " + user.getEmail());
            }
            
            // 2. 사용자 저장
            User savedUser = userRepository.save(user);
            
            // 3. 환영 이메일 발송 (비동기, 실패해도 등록은 완료)
            emailService.sendWelcomeEmailAsync(savedUser);
            
            // 4. 감사 로그 기록 (비동기, 실패해도 등록은 완료)
            auditService.logUserRegistrationAsync(savedUser);
            
            return savedUser;
            
        } catch (BusinessException e) {
            throw e;
        } catch (Exception e) {
            log.error("User registration failed", e);
            throw new SystemException("User registration failed", e);
        }
    }
}

// 2. 이메일 서비스
@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class EmailService {
    
    @Async
    public void sendWelcomeEmailAsync(User user) {
        try {
            sendWelcomeEmail(user);
        } catch (Exception e) {
            log.error("Failed to send welcome email for user: {}", user.getId(), e);
        }
    }
    
    public void sendWelcomeEmail(User user) {
        // 환영 이메일 발송 로직
        log.info("Welcome email sent to user: {}", user.getEmail());
    }
}

// 3. 감사 서비스
@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class AuditService {
    
    @Async
    public void logUserRegistrationAsync(User user) {
        try {
            logUserRegistration(user);
        } catch (Exception e) {
            log.error("Failed to log user registration for user: {}", user.getId(), e);
        }
    }
    
    public void logUserRegistration(User user) {
        // 사용자 등록 감사 로그 기록
        log.info("User registration logged for user: {}", user.getId());
    }
}
```

**설명:**
- **UserService**: BusinessException과 SystemException 발생 시 롤백
- **EmailService**: NOT_SUPPORTED로 트랜잭션과 분리, 비동기 처리
- **AuditService**: REQUIRES_NEW로 독립적인 트랜잭션, 비동기 처리
- **예외 처리**: 각 계층별로 적절한 예외 처리 및 변환

---

## 문제 4: 동시성 제어 (20점)

### 답안
```
동시성 문제 분석:

1. Lost Update 문제:
   - 두 트랜잭션이 동시에 같은 상품의 재고를 읽고 수정
   - 하나의 업데이트가 손실될 수 있음
   - 예: 재고 100에서 2개 트랜잭션이 각각 10개씩 차감하면 90이 되어야 하는데 80이 될 수 있음

2. Race Condition 문제:
   - 재고 확인과 차감 사이에 다른 트랜잭션이 끼어들 수 있음
   - 재고가 부족한데도 차감이 발생할 수 있음

3. 데이터 일관성 문제:
   - 동시 업데이트로 인한 데이터 불일치
   - 재고 수량이 음수가 될 수 있음

해결방안:

1. 격리 수준 조정:
   - REPEATABLE_READ 이상 사용하여 읽기 일관성 보장
   - Lost Update 방지

2. 락 사용:
   - 비관적 락으로 동시 접근 제어
   - SELECT FOR UPDATE 사용

3. 낙관적 락 사용:
   - @Version 어노테이션으로 버전 관리
   - 동시 수정 시 예외 발생

해결된 코드:
```

```java
@Service
@Transactional(
    isolation = Isolation.REPEATABLE_READ,
    rollbackFor = {BusinessException.class, SystemException.class}
)
public class InventoryService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public void updateStock(Long productId, int quantity) {
        try {
            // 비관적 락으로 상품 조회
            Product product = productRepository.findByIdForUpdate(productId)
                .orElseThrow(() -> new BusinessException("Product not found: " + productId));
            
            // 재고 확인
            if (product.getStock() < quantity) {
                throw new InsufficientStockException("Insufficient stock");
            }
            
            // 재고 차감
            product.setStock(product.getStock() - quantity);
            productRepository.save(product);
            
        } catch (InsufficientStockException e) {
            throw e;
        } catch (Exception e) {
            log.error("Stock update failed for product: {}", productId, e);
            throw new SystemException("Stock update failed", e);
        }
    }
}

// Product 엔티티에 낙관적 락 추가
@Entity
@Table(name = "products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private Integer stock;
    
    @Version
    private Long version; // 낙관적 락을 위한 버전 필드
    
    // getter, setter 생략
}

// Repository에 비관적 락 메서드 추가
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdForUpdate(@Param("id") Long id);
}
```

---

## 문제 5: 종합 설계 (10점)

### 답안
```
전체 시스템 트랜잭션 설계:

1. 서비스 계층별 트랜잭션 전략:
   - 주문 서비스: @Transactional(rollbackFor = {BusinessException.class, SystemException.class})
   - 재고 서비스: @Transactional(isolation = Isolation.REPEATABLE_READ, rollbackFor = {InsufficientStockException.class})
   - 결제 서비스: @Transactional(rollbackFor = {PaymentException.class})
   - 알림 서비스: @Transactional(propagation = Propagation.NOT_SUPPORTED)
   - 감사 서비스: @Transactional(propagation = Propagation.REQUIRES_NEW)

2. 트랜잭션 전파 전략:
   - 메인 비즈니스 로직: REQUIRED (기본값)
   - 독립적인 작업: REQUIRES_NEW (결제, 감사)
   - 트랜잭션과 무관한 작업: NOT_SUPPORTED (알림)

3. 격리 수준 전략:
   - 일반적인 작업: READ_COMMITTED
   - 재고 관리: REPEATABLE_READ
   - 금융 거래: SERIALIZABLE (필요한 경우에만)

4. 롤백 정책:
   - 비즈니스 예외: rollbackFor = {BusinessException.class}
   - 시스템 예외: rollbackFor = {SystemException.class}
   - 알림 실패: 롤백하지 않음

5. 성능 최적화 전략:
   - 트랜잭션 범위 최소화
   - 외부 API 호출을 비동기로 분리
   - 적절한 격리 수준 선택
   - 데드락 방지 전략

6. 예외 처리 전략:
   - 계층별 예외 변환
   - 비즈니스 예외와 시스템 예외 구분
   - 로깅과 롤백의 관계 고려

7. 모니터링 전략:
   - 트랜잭션 성능 측정
   - 데드락 감지
   - 롤백 비율 모니터링
   - 동시성 성능 측정
```

---

## 추가 학습 포인트

### 1. 실무 적용 시 주의사항
- 트랜잭션 범위를 최소화하여 성능 최적화
- 적절한 격리 수준 선택으로 성능과 일관성의 균형
- 예외 처리 계층별 분리로 유지보수성 향상
- 모니터링을 통한 지속적인 성능 개선

### 2. 팀 내 표준화
- 트랜잭션 설계 가이드라인 수립
- 코드 리뷰 시 트랜잭션 설계 검토
- 성능 테스트를 통한 검증
- 문서화를 통한 지식 공유

### 3. 지속적인 학습
- 새로운 트랜잭션 관리 기술 학습
- 성능 최적화 기법 연구
- 실무 경험을 통한 개선
- 커뮤니티와의 지식 공유
