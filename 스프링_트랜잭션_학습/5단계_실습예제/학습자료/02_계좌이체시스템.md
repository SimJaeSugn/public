# 계좌 이체 시스템 구현

## 1. 시스템 개요

### 1.1 요구사항
- **계좌 이체**: 한 계좌에서 다른 계좌로 돈을 이체
- **잔액 확인**: 이체 전 잔액 확인
- **동시성 제어**: 동시 이체 시 데이터 일관성 보장
- **이체 기록**: 모든 이체 내역을 기록
- **이체 취소**: 이체 실패 시 원상복구

### 1.2 도메인 모델
```java
// 계좌 엔티티
@Entity
@Table(name = "accounts")
public class Account {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String accountNumber;
    
    @Column(nullable = false)
    private String accountHolder;
    
    @Column(nullable = false)
    private BigDecimal balance;
    
    @Version
    private Long version; // 낙관적 락을 위한 버전 필드
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // getter, setter 생략
}

// 이체 엔티티
@Entity
@Table(name = "transfers")
public class Transfer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String fromAccountNumber;
    
    @Column(nullable = false)
    private String toAccountNumber;
    
    @Column(nullable = false)
    private BigDecimal amount;
    
    @Enumerated(EnumType.STRING)
    private TransferStatus status;
    
    @Column
    private String description;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    // getter, setter 생략
}

// 이체 상태 열거형
public enum TransferStatus {
    PENDING,    // 대기
    COMPLETED,  // 완료
    FAILED,     // 실패
    CANCELLED   // 취소
}
```

## 2. 서비스 계층 구현

### 2.1 계좌 서비스 (AccountService)
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    @Autowired
    private TransferRepository transferRepository;
    
    @Autowired
    private AuditService auditService;
    
    /**
     * 계좌 이체
     */
    @Transactional(
        isolation = Isolation.REPEATABLE_READ,
        rollbackFor = {BusinessException.class, SystemException.class}
    )
    public Transfer transferMoney(TransferRequest request) {
        try {
            // 1. 이체 기록 생성
            Transfer transfer = createTransferEntity(request);
            transfer = transferRepository.save(transfer);
            
            // 2. 계좌 잠금 및 잔액 확인
            Account fromAccount = lockAccount(request.getFromAccountNumber());
            Account toAccount = lockAccount(request.getToAccountNumber());
            
            // 3. 잔액 확인
            if (fromAccount.getBalance().compareTo(request.getAmount()) < 0) {
                transfer.setStatus(TransferStatus.FAILED);
                transferRepository.save(transfer);
                throw new InsufficientFundsException("Insufficient funds");
            }
            
            // 4. 이체 처리
            fromAccount.setBalance(fromAccount.getBalance().subtract(request.getAmount()));
            toAccount.setBalance(toAccount.getBalance().add(request.getAmount()));
            
            accountRepository.save(fromAccount);
            accountRepository.save(toAccount);
            
            // 5. 이체 완료
            transfer.setStatus(TransferStatus.COMPLETED);
            transfer = transferRepository.save(transfer);
            
            // 6. 감사 로그
            auditService.logTransfer(transfer);
            
            return transfer;
            
        } catch (InsufficientFundsException e) {
            log.warn("Insufficient funds for transfer: {}", request, e);
            throw e;
            
        } catch (Exception e) {
            log.error("Transfer failed: {}", request, e);
            throw new SystemException("Transfer failed", e);
        }
    }
    
    /**
     * 계좌 잠금 (데드락 방지를 위해 ID 순서로 정렬)
     */
    private Account lockAccount(String accountNumber) {
        Account account = accountRepository.findByAccountNumberForUpdate(accountNumber)
            .orElseThrow(() -> new BusinessException("Account not found: " + accountNumber));
        return account;
    }
    
    /**
     * 계좌 조회 (읽기 전용)
     */
    @Transactional(readOnly = true)
    public Account getAccount(String accountNumber) {
        return accountRepository.findByAccountNumber(accountNumber)
            .orElseThrow(() -> new BusinessException("Account not found: " + accountNumber));
    }
    
    /**
     * 계좌 생성
     */
    public Account createAccount(CreateAccountRequest request) {
        try {
            Account account = new Account();
            account.setAccountNumber(request.getAccountNumber());
            account.setAccountHolder(request.getAccountHolder());
            account.setBalance(request.getInitialBalance());
            
            return accountRepository.save(account);
            
        } catch (Exception e) {
            log.error("Account creation failed: {}", request, e);
            throw new SystemException("Account creation failed", e);
        }
    }
    
    private Transfer createTransferEntity(TransferRequest request) {
        Transfer transfer = new Transfer();
        transfer.setFromAccountNumber(request.getFromAccountNumber());
        transfer.setToAccountNumber(request.getToAccountNumber());
        transfer.setAmount(request.getAmount());
        transfer.setDescription(request.getDescription());
        transfer.setStatus(TransferStatus.PENDING);
        return transfer;
    }
}
```

### 2.2 이체 서비스 (TransferService)
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class TransferService {
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private TransferRepository transferRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 이체 처리 (메인 로직)
     */
    public Transfer processTransfer(TransferRequest request) {
        try {
            // 1. 이체 실행
            Transfer transfer = accountService.transferMoney(request);
            
            // 2. 알림 발송 (비동기)
            notificationService.sendTransferNotificationAsync(transfer);
            
            return transfer;
            
        } catch (BusinessException e) {
            throw e;
        } catch (Exception e) {
            log.error("Transfer processing failed: {}", request, e);
            throw new SystemException("Transfer processing failed", e);
        }
    }
    
    /**
     * 이체 내역 조회
     */
    @Transactional(readOnly = true)
    public List<Transfer> getTransferHistory(String accountNumber) {
        try {
            return transferRepository.findByFromAccountNumberOrToAccountNumberOrderByCreatedAtDesc(
                accountNumber, accountNumber);
        } catch (Exception e) {
            log.error("Failed to get transfer history for account: {}", accountNumber, e);
            throw new SystemException("Failed to get transfer history", e);
        }
    }
    
    /**
     * 이체 취소 (실패한 이체만)
     */
    @Transactional(rollbackFor = {BusinessException.class, SystemException.class})
    public void cancelTransfer(Long transferId) {
        try {
            Transfer transfer = transferRepository.findById(transferId)
                .orElseThrow(() -> new BusinessException("Transfer not found: " + transferId));
            
            if (transfer.getStatus() != TransferStatus.FAILED) {
                throw new BusinessException("Only failed transfers can be cancelled");
            }
            
            transfer.setStatus(TransferStatus.CANCELLED);
            transferRepository.save(transfer);
            
        } catch (BusinessException e) {
            throw e;
        } catch (Exception e) {
            log.error("Transfer cancellation failed: {}", transferId, e);
            throw new SystemException("Transfer cancellation failed", e);
        }
    }
}
```

### 2.3 알림 서비스 (NotificationService)
```java
@Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class NotificationService {
    
    @Autowired
    private EmailRepository emailRepository;
    
    /**
     * 이체 알림 발송 (비동기)
     */
    @Async
    public void sendTransferNotificationAsync(Transfer transfer) {
        try {
            sendTransferNotification(transfer);
        } catch (Exception e) {
            log.error("Failed to send transfer notification for transfer: {}", transfer.getId(), e);
        }
    }
    
    /**
     * 이체 알림 발송
     */
    public void sendTransferNotification(Transfer transfer) {
        try {
            Email email = new Email();
            email.setTo("user@example.com");
            email.setSubject("Transfer Notification");
            email.setBody(String.format(
                "Transfer completed: %s -> %s, Amount: %s",
                transfer.getFromAccountNumber(),
                transfer.getToAccountNumber(),
                transfer.getAmount()
            ));
            
            emailRepository.save(email);
            
            log.info("Transfer notification sent for transfer: {}", transfer.getId());
            
        } catch (Exception e) {
            log.error("Failed to send transfer notification for transfer: {}", transfer.getId(), e);
            throw new NotificationException("Email sending failed", e);
        }
    }
}
```

## 3. 컨트롤러 계층 구현

### 3.1 이체 컨트롤러 (TransferController)
```java
@RestController
@RequestMapping("/api/transfers")
public class TransferController {
    
    @Autowired
    private TransferService transferService;
    
    @Autowired
    private AccountService accountService;
    
    /**
     * 이체 실행
     */
    @PostMapping
    public ResponseEntity<TransferResponse> processTransfer(@RequestBody @Valid TransferRequest request) {
        try {
            Transfer transfer = transferService.processTransfer(request);
            TransferResponse response = convertToResponse(transfer);
            return ResponseEntity.ok(response);
            
        } catch (InsufficientFundsException e) {
            log.warn("Insufficient funds for transfer: {}", e.getMessage());
            return ResponseEntity.badRequest().body(null);
            
        } catch (BusinessException e) {
            log.warn("Business error during transfer: {}", e.getMessage());
            return ResponseEntity.badRequest().body(null);
            
        } catch (SystemException e) {
            log.error("System error during transfer", e);
            return ResponseEntity.status(500).body(null);
            
        } catch (Exception e) {
            log.error("Unexpected error during transfer", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * 계좌 조회
     */
    @GetMapping("/accounts/{accountNumber}")
    public ResponseEntity<AccountResponse> getAccount(@PathVariable String accountNumber) {
        try {
            Account account = accountService.getAccount(accountNumber);
            AccountResponse response = convertToResponse(account);
            return ResponseEntity.ok(response);
            
        } catch (BusinessException e) {
            log.warn("Account not found: {}", accountNumber);
            return ResponseEntity.notFound().build();
            
        } catch (Exception e) {
            log.error("Unexpected error during account retrieval", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * 이체 내역 조회
     */
    @GetMapping("/history/{accountNumber}")
    public ResponseEntity<List<TransferResponse>> getTransferHistory(@PathVariable String accountNumber) {
        try {
            List<Transfer> transfers = transferService.getTransferHistory(accountNumber);
            List<TransferResponse> responses = transfers.stream()
                .map(this::convertToResponse)
                .collect(Collectors.toList());
            return ResponseEntity.ok(responses);
            
        } catch (Exception e) {
            log.error("Unexpected error during transfer history retrieval", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    private TransferResponse convertToResponse(Transfer transfer) {
        TransferResponse response = new TransferResponse();
        response.setId(transfer.getId());
        response.setFromAccountNumber(transfer.getFromAccountNumber());
        response.setToAccountNumber(transfer.getToAccountNumber());
        response.setAmount(transfer.getAmount());
        response.setStatus(transfer.getStatus());
        response.setDescription(transfer.getDescription());
        response.setCreatedAt(transfer.getCreatedAt());
        return response;
    }
    
    private AccountResponse convertToResponse(Account account) {
        AccountResponse response = new AccountResponse();
        response.setId(account.getId());
        response.setAccountNumber(account.getAccountNumber());
        response.setAccountHolder(account.getAccountHolder());
        response.setBalance(account.getBalance());
        response.setCreatedAt(account.getCreatedAt());
        return response;
    }
}
```

## 4. 테스트 코드 구현

### 4.1 이체 서비스 테스트
```java
@SpringBootTest
@Transactional
class TransferServiceTest {
    
    @Autowired
    private TransferService transferService;
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private AccountRepository accountRepository;
    
    @Test
    @DisplayName("이체 성공 테스트")
    void processTransfer_Success() {
        // Given
        Account fromAccount = createTestAccount("1234567890", new BigDecimal("1000.00"));
        Account toAccount = createTestAccount("0987654321", new BigDecimal("500.00"));
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        
        TransferRequest request = createTestTransferRequest("1234567890", "0987654321", new BigDecimal("100.00"));
        
        // When
        Transfer transfer = transferService.processTransfer(request);
        
        // Then
        assertThat(transfer).isNotNull();
        assertThat(transfer.getStatus()).isEqualTo(TransferStatus.COMPLETED);
        assertThat(transfer.getAmount()).isEqualTo(new BigDecimal("100.00"));
        
        // 계좌 잔액 확인
        Account updatedFromAccount = accountRepository.findByAccountNumber("1234567890").orElseThrow();
        Account updatedToAccount = accountRepository.findByAccountNumber("0987654321").orElseThrow();
        
        assertThat(updatedFromAccount.getBalance()).isEqualTo(new BigDecimal("900.00"));
        assertThat(updatedToAccount.getBalance()).isEqualTo(new BigDecimal("600.00"));
    }
    
    @Test
    @DisplayName("잔액 부족 시 이체 실패 테스트")
    void processTransfer_InsufficientFunds() {
        // Given
        Account fromAccount = createTestAccount("1234567890", new BigDecimal("50.00"));
        Account toAccount = createTestAccount("0987654321", new BigDecimal("500.00"));
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        
        TransferRequest request = createTestTransferRequest("1234567890", "0987654321", new BigDecimal("100.00"));
        
        // When & Then
        assertThatThrownBy(() -> transferService.processTransfer(request))
            .isInstanceOf(InsufficientFundsException.class)
            .hasMessageContaining("Insufficient funds");
    }
    
    @Test
    @DisplayName("동시 이체 테스트")
    void processTransfer_Concurrent() throws InterruptedException {
        // Given
        Account fromAccount = createTestAccount("1234567890", new BigDecimal("1000.00"));
        Account toAccount = createTestAccount("0987654321", new BigDecimal("500.00"));
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        
        TransferRequest request1 = createTestTransferRequest("1234567890", "0987654321", new BigDecimal("100.00"));
        TransferRequest request2 = createTestTransferRequest("1234567890", "0987654321", new BigDecimal("200.00"));
        
        // When
        CompletableFuture<Transfer> future1 = CompletableFuture.supplyAsync(() -> 
            transferService.processTransfer(request1));
        CompletableFuture<Transfer> future2 = CompletableFuture.supplyAsync(() -> 
            transferService.processTransfer(request2));
        
        CompletableFuture.allOf(future1, future2).join();
        
        // Then
        Transfer transfer1 = future1.get();
        Transfer transfer2 = future2.get();
        
        assertThat(transfer1.getStatus()).isEqualTo(TransferStatus.COMPLETED);
        assertThat(transfer2.getStatus()).isEqualTo(TransferStatus.COMPLETED);
        
        // 최종 잔액 확인
        Account finalFromAccount = accountRepository.findByAccountNumber("1234567890").orElseThrow();
        Account finalToAccount = accountRepository.findByAccountNumber("0987654321").orElseThrow();
        
        assertThat(finalFromAccount.getBalance()).isEqualTo(new BigDecimal("700.00")); // 1000 - 100 - 200
        assertThat(finalToAccount.getBalance()).isEqualTo(new BigDecimal("800.00")); // 500 + 100 + 200
    }
    
    private Account createTestAccount(String accountNumber, BigDecimal balance) {
        Account account = new Account();
        account.setAccountNumber(accountNumber);
        account.setAccountHolder("Test Holder");
        account.setBalance(balance);
        return account;
    }
    
    private TransferRequest createTestTransferRequest(String fromAccount, String toAccount, BigDecimal amount) {
        TransferRequest request = new TransferRequest();
        request.setFromAccountNumber(fromAccount);
        request.setToAccountNumber(toAccount);
        request.setAmount(amount);
        request.setDescription("Test transfer");
        return request;
    }
}
```

### 4.2 통합 테스트
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.ANY)
class TransferIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private AccountRepository accountRepository;
    
    @Test
    @DisplayName("이체 통합 테스트")
    void processTransfer_IntegrationTest() {
        // Given
        Account fromAccount = createTestAccount("1234567890", new BigDecimal("1000.00"));
        Account toAccount = createTestAccount("0987654321", new BigDecimal("500.00"));
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        
        TransferRequest request = createTestTransferRequest("1234567890", "0987654321", new BigDecimal("100.00"));
        
        // When
        ResponseEntity<TransferResponse> response = restTemplate.postForEntity(
            "/api/transfers", request, TransferResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getStatus()).isEqualTo(TransferStatus.COMPLETED);
    }
    
    private Account createTestAccount(String accountNumber, BigDecimal balance) {
        Account account = new Account();
        account.setAccountNumber(accountNumber);
        account.setAccountHolder("Test Holder");
        account.setBalance(balance);
        return account;
    }
    
    private TransferRequest createTestTransferRequest(String fromAccount, String toAccount, BigDecimal amount) {
        TransferRequest request = new TransferRequest();
        request.setFromAccountNumber(fromAccount);
        request.setToAccountNumber(toAccount);
        request.setAmount(amount);
        request.setDescription("Test transfer");
        return request;
    }
}
```

## 5. 성능 최적화 및 모니터링

### 5.1 데드락 방지 전략
```java
@Service
@Transactional(rollbackFor = {BusinessException.class, SystemException.class})
public class DeadlockPreventionService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    /**
     * 데드락 방지를 위한 계좌 잠금 순서 정렬
     */
    private Account lockAccount(String accountNumber) {
        // 계좌 번호를 정렬하여 데드락 방지
        return accountRepository.findByAccountNumberForUpdate(accountNumber)
            .orElseThrow(() -> new BusinessException("Account not found: " + accountNumber));
    }
    
    /**
     * 이체 시 계좌 잠금 순서 보장
     */
    public Transfer transferMoney(TransferRequest request) {
        String fromAccount = request.getFromAccountNumber();
        String toAccount = request.getToAccountNumber();
        
        // 계좌 번호 순서로 정렬하여 데드락 방지
        if (fromAccount.compareTo(toAccount) < 0) {
            Account from = lockAccount(fromAccount);
            Account to = lockAccount(toAccount);
            return processTransfer(from, to, request);
        } else {
            Account to = lockAccount(toAccount);
            Account from = lockAccount(fromAccount);
            return processTransfer(from, to, request);
        }
    }
    
    private Transfer processTransfer(Account from, Account to, TransferRequest request) {
        // 이체 처리 로직
        return null;
    }
}
```

### 5.2 성능 모니터링
```java
@Component
@Aspect
public class TransferPerformanceAspect {
    
    private static final Logger log = LoggerFactory.getLogger(TransferPerformanceAspect.class);
    
    @Around("execution(* com.example.service.TransferService.processTransfer(..))")
    public Object measureTransferPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            long executionTime = System.currentTimeMillis() - startTime;
            
            if (executionTime > 500) { // 500ms 이상
                log.warn("Slow transfer detected: {} took {}ms", 
                    joinPoint.getSignature().getName(), executionTime);
            }
            
            return result;
            
        } catch (Exception e) {
            long executionTime = System.currentTimeMillis() - startTime;
            log.error("Transfer failed after {}ms: {}", 
                executionTime, joinPoint.getSignature().getName(), e);
            throw e;
        }
    }
}
```

이제 다음 학습 자료에서 사용자 관리 시스템을 구현해보겠습니다.
